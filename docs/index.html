<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · Juissie.jl</title><meta name="title" content="Home · Juissie.jl"/><meta property="og:title" content="Home · Juissie.jl"/><meta property="twitter:title" content="Home · Juissie.jl"/><meta name="description" content="Documentation for Juissie.jl."/><meta property="og:description" content="Documentation for Juissie.jl."/><meta property="twitter:description" content="Documentation for Juissie.jl."/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>Juissie.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li><a class="tocitem" href="#Introduction"><span>Introduction</span></a></li><li><a class="tocitem" href="#Installation"><span>Installation</span></a></li><li><a class="tocitem" href="#Verify-setup"><span>Verify setup</span></a></li><li><a class="tocitem" href="#Usage"><span>Usage</span></a></li><li><a class="tocitem" href="#API-Keys"><span>API Keys</span></a></li><li><a class="tocitem" href="#Functions"><span>Functions</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/Juissie-GW/Juissie.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/Juissie-GW/Juissie.jl/blob/main/docs/src/index.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Juissie.jl"><a class="docs-heading-anchor" href="#Juissie.jl">Juissie.jl</a><a id="Juissie.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Juissie.jl" title="Permalink"></a></h1><p>JUISSIE is a Julia-native semantic query engine, is versatile for integration as a package in software development workflows or through its desktop user interface.</p><h2 id="Introduction"><a class="docs-heading-anchor" href="#Introduction">Introduction</a><a id="Introduction-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction" title="Permalink"></a></h2><p>Juissie is a Julia-native semantic query engine. It can be used as a package in software development workflows, or via its desktop user interface.</p><p>Juissie was developed as a class project for CSCI 6221: Advanced Software Paradigms at The George Washington University.</p><h2 id="Installation"><a class="docs-heading-anchor" href="#Installation">Installation</a><a id="Installation-1"></a><a class="docs-heading-anchor-permalink" href="#Installation" title="Permalink"></a></h2><ol><li>Clone this repo</li><li>Navigate into the cloned repo directory:</li></ol><pre><code class="language-bash hljs">cd Juissie</code></pre><p>In general, we assume the user is running the <code>julia</code> command, and all other commands (e.g., <code>jupyter notebook</code>), from the root level of this project.</p><ol><li>Open the Julia REPL by typing <code>julia</code> into the terminal. Then, install the package dependencies:</li></ol><pre><code class="language-julia hljs">using Pkg
Pkg.activate(&quot;.&quot;)
Pkg.resolve()
Pkg.instantiate()</code></pre><p>To use our generators, you may need an OpenAI API key <a href="#api-keys">see here</a>. To run our demo Jupyter notebooks, you may need to setup Jupyter <a href="#running-jupyter-notebooks">see here</a>.</p><h2 id="Verify-setup"><a class="docs-heading-anchor" href="#Verify-setup">Verify setup</a><a id="Verify-setup-1"></a><a class="docs-heading-anchor-permalink" href="#Verify-setup" title="Permalink"></a></h2><ol><li>From this repo&#39;s home directory, open the Julia REPL by typing <code>julia</code> into the terminal. Then, try importing the Juissie module:</li></ol><pre><code class="language-julia hljs">using Juissie</code></pre><p>This should expose symbols like <code>Corpus</code>, <code>Embedder</code>, <code>upsert_chunk</code>, <code>upsert_document</code>, <code>search</code>, and <code>embed</code>.</p><ol><li>Try instantiating one of the exported struct, like <code>Corpus</code>:</li></ol><pre><code class="language-julia hljs">corpus = Corpus()</code></pre><p>We can test the <code>upsert</code> and search functionality associated with <code>Corpus</code> like so:</p><pre><code class="language-julia hljs">upsert_chunk(corpus, &quot;Hold me closer, tiny dancer.&quot;, &quot;doc1&quot;)
upsert_chunk(corpus, &quot;Count the headlights on the highway.&quot;, &quot;doc1&quot;)
upsert_chunk(corpus, &quot;Lay me down in sheets of linen.&quot;, &quot;doc2&quot;)
upsert_chunk(corpus, &quot;Peter Piper picked a peck of pickled peppers. A peck of pickled peppers, Peter Piper picked.&quot;, &quot;doc2&quot;)</code></pre><p>Search those chunks:</p><pre><code class="language-julia hljs">idx_list, doc_names, chunks, distances = search(
    corpus, 
    &quot;tiny dancer&quot;, 
    2
)</code></pre><p>The output should look like this:</p><pre><code class="language-bash hljs">([1, 3], [&quot;doc1&quot;, &quot;doc2&quot;], [&quot;Hold me closer, tiny dancer.&quot;, &quot;Lay me down in sheets of linen.&quot;], Vector{Float32}[[5.198073, 9.5337925]])</code></pre><h2 id="Usage"><a class="docs-heading-anchor" href="#Usage">Usage</a><a id="Usage-1"></a><a class="docs-heading-anchor-permalink" href="#Usage" title="Permalink"></a></h2><h3 id="Desktop-UI"><a class="docs-heading-anchor" href="#Desktop-UI">Desktop UI</a><a id="Desktop-UI-1"></a><a class="docs-heading-anchor-permalink" href="#Desktop-UI" title="Permalink"></a></h3><p>Navigate to the root directory of this repository (<code>Juissie.jl</code>), enter the following into the command line, and press the enter/return key:</p><pre><code class="language-bash hljs">julia src/Frontend.jl</code></pre><p>This will launch our application:</p><img src="https://raw.githubusercontent.com/Juissie-GW/Juissie.jl/main/assets/ui1.png" alt="ui1" width="500"/><h2 id="API-Keys"><a class="docs-heading-anchor" href="#API-Keys">API Keys</a><a id="API-Keys-1"></a><a class="docs-heading-anchor-permalink" href="#API-Keys" title="Permalink"></a></h2><p>Juissie&#39;s default generator requires an OpenAI API key. This can be provided manually in the UI (see the <code>API Key</code> tab of the Corpus Manager) or passed as an argument when initializing the generator. The preferred method, however, is to <a href="#managing-api-keys">stash your API key in a <code>.env</code> file</a>.</p><h3 id="Obtaining-an-OpenAI-API-Key"><a class="docs-heading-anchor" href="#Obtaining-an-OpenAI-API-Key">Obtaining an OpenAI API Key</a><a id="Obtaining-an-OpenAI-API-Key-1"></a><a class="docs-heading-anchor-permalink" href="#Obtaining-an-OpenAI-API-Key" title="Permalink"></a></h3><ol><li>Create an OpenAI account <a href="https://auth0.openai.com/u/signup">here</a>.</li><li>Set up billing information (each query has a small cost) <a href="https://platform.openai.com/account/billing/payment-methods">here</a>.</li><li>Create a new secret key <a href="https://platform.openai.com/api-keys">here</a>.</li></ol><h3 id="Managing-API-Keys"><a class="docs-heading-anchor" href="#Managing-API-Keys">Managing API Keys</a><a id="Managing-API-Keys-1"></a><a class="docs-heading-anchor-permalink" href="#Managing-API-Keys" title="Permalink"></a></h3><p>Secure management of secret keys is important. Every user should create a <code>.env</code> file in the project root where they add their API key(s), e.g.:</p><pre><code class="language-bash hljs">OAI_KEY=ABC123</code></pre><p>These may be accessed using Julia via the <code>DotEnv</code> library. First, run the <code>julia</code> command in a terminal. Then install <code>DotEnv</code>:</p><pre><code class="language-julia hljs">import Pkg
Pkg.add(&quot;DotEnv&quot;)</code></pre><p>Then, use it to access environmental variables from your <code>.env</code> file:</p><pre><code class="language-julia hljs">using DotEnv
cfg = DotEnv.config()

api_key = cfg[&quot;OAI_KEY&quot;]</code></pre><p>Note that DotEnv looks for <code>.env</code> in the <em>current</em> directory, i.e. that of where you called <code>julia</code> from.  If <code>.env</code> is in a different path, you have to provide it, e.g. <code>DotEnv.config(YOUR_PATH_HERE)</code>. If you are invoking Juissie from the root directory of this repo (typical), this means the <code>.env</code> should be placed there.</p><h2 id="Functions"><a class="docs-heading-anchor" href="#Functions">Functions</a><a id="Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Juissie.Generation.SemanticSearch.Embedding.embed-Tuple{Juissie.Generation.SemanticSearch.Embedding.Embedder, String}" href="#Juissie.Generation.SemanticSearch.Embedding.embed-Tuple{Juissie.Generation.SemanticSearch.Embedding.Embedder, String}"><code>Juissie.Generation.SemanticSearch.Embedding.embed</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function embed(embedder::Embedder, text::String)::AbstractVector</code></pre><p>Embeds a textual sequence using a provided model</p><p><strong>Parameters</strong></p><p>embedder : Embedder     an initialized Embedder struct text : String     the text sequence you want to embed</p><p><strong>Notes</strong></p><p>This is sort of like a class method for the Embedder</p><p>Julia has something called multiple dispatch that can be used to  make this cleaner, but I&#39;m going to handle that at a later times</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Juissie-GW/Juissie.jl/blob/15e686ea43ed50150619b8fe99cf4f4d60cabbe5/src/SemanticSearch/Embedding.jl#L53-L71">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Juissie.Generation.SemanticSearch.Embedding.embed_from_bert-Tuple{Juissie.Generation.SemanticSearch.Embedding.Embedder, String}" href="#Juissie.Generation.SemanticSearch.Embedding.embed_from_bert-Tuple{Juissie.Generation.SemanticSearch.Embedding.Embedder, String}"><code>Juissie.Generation.SemanticSearch.Embedding.embed_from_bert</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function embed_from_bert(embedder::Embedder, text::String)</code></pre><p>Embeds a textual sequence using a provided Bert model</p><p><strong>Parameters</strong></p><p>embedder : Embedder     an initialized Embedder struct     the associated model and tokenizer should be Bert-specific text : String     the text sequence you want to embed</p><p>return : cls_embedding     The results from passing the text through the encoder, throught the model,     and after stripping </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Juissie-GW/Juissie.jl/blob/15e686ea43ed50150619b8fe99cf4f4d60cabbe5/src/SemanticSearch/Embedding.jl#L85-L101">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Juissie.Generation.SemanticSearch.Embedding.Embedder" href="#Juissie.Generation.SemanticSearch.Embedding.Embedder"><code>Juissie.Generation.SemanticSearch.Embedding.Embedder</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Embedder</code></pre><p>A struct for holding a model and a tokenizer</p><p><strong>Attributes</strong></p><p>tokenizer : a tokenizer object, e.g. BertTextEncoder     maps your string to tokens the model can understand model : a model object, e.g. HGFBertModel     the actual model architecture and weights to perform inference with</p><p><strong>Notes</strong></p><p>You can get class-like behavior in Julia by defining a struct and functions that operate on that struct.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Juissie-GW/Juissie.jl/blob/15e686ea43ed50150619b8fe99cf4f4d60cabbe5/src/SemanticSearch/Embedding.jl#L12-L28">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Juissie.Generation.SemanticSearch.Embedding.Embedder-Tuple{String}" href="#Juissie.Generation.SemanticSearch.Embedding.Embedder-Tuple{String}"><code>Juissie.Generation.SemanticSearch.Embedding.Embedder</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function Embedder(model_name::String)</code></pre><p>Function to initialize an Embedder struct from a HuggingFace model path.</p><p><strong>Parameters</strong></p><p>model_name : String     a path to a HuggingFace-hosted model     e.g. &quot;BAAI/bge-small-en-v1.5&quot;</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Juissie-GW/Juissie.jl/blob/15e686ea43ed50150619b8fe99cf4f4d60cabbe5/src/SemanticSearch/Embedding.jl#L35-L46">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Juissie.SemanticSearch.Backend.index-Tuple{Corpus}" href="#Juissie.SemanticSearch.Backend.index-Tuple{Corpus}"><code>Juissie.SemanticSearch.Backend.index</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function index(corpus::Corpus)</code></pre><p>Constructs the HNSW vector index from the data available. If the corpus has a corpus_name, then we also save the new index to disk. Must be run before searching.</p><p><strong>Parameters</strong></p><p>corpus : an initialized Corpus object     the corpus / &quot;vector database&quot; you want to use</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Juissie-GW/Juissie.jl/blob/15e686ea43ed50150619b8fe99cf4f4d60cabbe5/src/SemanticSearch/Backend.jl#L398-L409">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Juissie.SemanticSearch.Backend.load_corpus-Tuple{String}" href="#Juissie.SemanticSearch.Backend.load_corpus-Tuple{String}"><code>Juissie.SemanticSearch.Backend.load_corpus</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function load_corpus(corpus_name)</code></pre><p>Loads an already-initialized corpus from its associated &quot;artifacts&quot; (relational database, vector index, and informational json).</p><p><strong>Parameters</strong></p><p>corpus_name : str     the name of your EXISTING vector database</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Juissie-GW/Juissie.jl/blob/15e686ea43ed50150619b8fe99cf4f4d60cabbe5/src/SemanticSearch/Backend.jl#L163-L173">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Juissie.SemanticSearch.Backend.search" href="#Juissie.SemanticSearch.Backend.search"><code>Juissie.SemanticSearch.Backend.search</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">function search(corpus::Corpus, query::String, k::Int=5)</code></pre><p>Performs approximate nearest neighbor search to find the items in the vector index closest to the query.</p><p><strong>Parameters</strong></p><p>corpus : an initialized Corpus object     the corpus / &quot;vector database&quot; you want to use query : str     The text you want to search, e.g. your question     We embed this and perform semantic retrieval against the vector db k : int     The number of nearest-neighbor vectors to fetch</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Juissie-GW/Juissie.jl/blob/15e686ea43ed50150619b8fe99cf4f4d60cabbe5/src/SemanticSearch/Backend.jl#L432-L447">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Juissie.SemanticSearch.Backend.upsert_chunk-Tuple{Corpus, String, String}" href="#Juissie.SemanticSearch.Backend.upsert_chunk-Tuple{Corpus, String, String}"><code>Juissie.SemanticSearch.Backend.upsert_chunk</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function upsert_chunk(corpus::Corpus, chunk::String, doc_name::String)</code></pre><p>Given a new chunk of text, get embedding and insert into our vector DB. Not actually a full upsert, because we have to reindex later. Process:</p><ol><li>Generate an embedding for the text</li><li>Insert metadata into database</li><li>Increment idx counter</li></ol><p><strong>Parameters</strong></p><p>corpus : an initialized Corpus object     the corpus / &quot;vector database&quot; you want to use chunk : str     This is the text content of the chunk you want to upsert doc<em>name : str     The name of the document that chunk is from. For instance, if you      were upserting all the chunks in an academic paper, doc</em>name might     be the name of that paper</p><p><strong>Notes</strong></p><p>If the vectors have been indexed, this de-indexes them (i.e., they need to be indexed again). Currently, we handle this by setting hnsw to  nothing so that it gets caught later in search.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Juissie-GW/Juissie.jl/blob/15e686ea43ed50150619b8fe99cf4f4d60cabbe5/src/SemanticSearch/Backend.jl#L239-L265">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Juissie.SemanticSearch.Backend.upsert_document-Tuple{Corpus, String, String}" href="#Juissie.SemanticSearch.Backend.upsert_document-Tuple{Corpus, String, String}"><code>Juissie.SemanticSearch.Backend.upsert_document</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function upsert_document(corpus::Corpus, doc_text::String, doc_name::String)</code></pre><p>Upsert a whole document (i.e., long string). Does so by splitting the document into appropriately-sized chunks so no chunk exceeds the embedder&#39;s tokenization max sequence length, while prioritizing sentence endings.</p><p><strong>Parameters</strong></p><p>corpus : an initialized Corpus object     the corpus / &quot;vector database&quot; you want to use doc<em>text : str     A long string you want to upsert. We will break this into chunks and     upsert each chunk. doc</em>name : str     The name of the document the content is from</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Juissie-GW/Juissie.jl/blob/15e686ea43ed50150619b8fe99cf4f4d60cabbe5/src/SemanticSearch/Backend.jl#L287-L303">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Juissie.SemanticSearch.Backend.upsert_document-Tuple{Corpus, Vector{String}, String}" href="#Juissie.SemanticSearch.Backend.upsert_document-Tuple{Corpus, Vector{String}, String}"><code>Juissie.SemanticSearch.Backend.upsert_document</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function upsert_document(corpus::Corpus, documents::Vector{String}, doc_name::String)</code></pre><p>Upsert a collection of documents (i.e., a vector of long strings). Does so by upserting each entry of the provided documents vector (which in turn will chunkify, each document further into appropriately sized chunks).</p><p>See the upsert_document(...) above for more details</p><p><strong>Parameters</strong></p><p>corpus : an initialized Corpus object     the corpus / &quot;vector database&quot; you want to use documents : Vector{String}     a collection of long strings to upsert. doc_name : str     The name of the document the content is from</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Juissie-GW/Juissie.jl/blob/15e686ea43ed50150619b8fe99cf4f4d60cabbe5/src/SemanticSearch/Backend.jl#L311-L328">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Juissie.SemanticSearch.Backend.upsert_document_from_pdf-Tuple{Corpus, String, String}" href="#Juissie.SemanticSearch.Backend.upsert_document_from_pdf-Tuple{Corpus, String, String}"><code>Juissie.SemanticSearch.Backend.upsert_document_from_pdf</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function upsert_document_from_pdf(corpus::Corpus, filePath::String, doc_name::String)</code></pre><p>Upsert all the data in a PDF file into the provided corpus. See the upsert_document(...) above for more details.</p><p><strong>Parameters</strong></p><p>corpus : an initialized Corpus object     the corpus / &quot;vector database&quot; you want to use filePath : String     The path to the PDF file to read doc_name : str     The name of the document the content is from</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Juissie-GW/Juissie.jl/blob/15e686ea43ed50150619b8fe99cf4f4d60cabbe5/src/SemanticSearch/Backend.jl#L361-L375">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Juissie.SemanticSearch.Backend.upsert_document_from_txt-Tuple{Corpus, String, String}" href="#Juissie.SemanticSearch.Backend.upsert_document_from_txt-Tuple{Corpus, String, String}"><code>Juissie.SemanticSearch.Backend.upsert_document_from_txt</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function upsert_document_from_txt(corpus::Corpus, filePath::String, doc_name::String)</code></pre><p>Upsert all the data from the text file into the provided corpus.</p><p><strong>Parameters</strong></p><p>corpus : an initialized Corpus object     the corpus / &quot;vector database&quot; you want to use filePath : String     The path to the txt file to read doc_name : str     The name of the document the content is from</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Juissie-GW/Juissie.jl/blob/15e686ea43ed50150619b8fe99cf4f4d60cabbe5/src/SemanticSearch/Backend.jl#L380-L393">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Juissie.SemanticSearch.Backend.upsert_document_from_url" href="#Juissie.SemanticSearch.Backend.upsert_document_from_url"><code>Juissie.SemanticSearch.Backend.upsert_document_from_url</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">function upsert_document_from_url(corpus::Corpus, url::String, doc_name::String, elements::Array{String}=[&quot;h1&quot;, &quot;h2&quot;, &quot;p&quot;])</code></pre><p>Extracts element-tagged text from HTML and upserts as a document.</p><p><strong>Parameters</strong></p><p>corpus : an initialized Corpus object     the corpus / &quot;vector database&quot; you want to use url : String     The url you want to scrape for text doc_name : str     The name of the document the content is from elements : Array{String}     A list of HTML elements you want to pull the text from</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Juissie-GW/Juissie.jl/blob/15e686ea43ed50150619b8fe99cf4f4d60cabbe5/src/SemanticSearch/Backend.jl#L335-L350">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Juissie.SemanticSearch.Backend.Corpus" href="#Juissie.SemanticSearch.Backend.Corpus"><code>Juissie.SemanticSearch.Backend.Corpus</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Corpus</code></pre><p>Basically a vector database. It will have these attributes:</p><ol><li>a relational database (SQLite)</li><li>a vector index (HNSW)</li><li>an embedder (via Embedding.jl)</li></ol><p><strong>Attributes</strong></p><p>corpus<em>name : String or Nothing     this is the name of your corpus and will be used to access saved          corpuses     if Nothing, we can&#39;t save/load and everything will be in-memory db : a SQLite.DB connection object     this is a real relational database to store metadata (e.g. chunk text, doc name) hnsw : Hierarchical Navigable Small World object     this is our searchable vector index embedder : Embedder     an initialized Embedder struct max</em>seq<em>len : int     The maximum number of tokens per chunk.     This should be the max sequence length of the tokenizer data : Vector{Any}     The embeddings get stored here before we create the vector index next</em>idx : int     stores the index we&#39;ll use for the next-upserted chunk</p><p><strong>Notes</strong></p><p>The struct is mutable because we want to be able to change things like incrementing next_idx.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Juissie-GW/Juissie.jl/blob/15e686ea43ed50150619b8fe99cf4f4d60cabbe5/src/SemanticSearch/Backend.jl#L32-L64">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Juissie.SemanticSearch.Backend.Corpus" href="#Juissie.SemanticSearch.Backend.Corpus"><code>Juissie.SemanticSearch.Backend.Corpus</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">function Corpus(corpus_name::String, embedder_model_path::String=&quot;BAAI/bge-small-en-v1.5&quot;)</code></pre><p>Initializes a Corpus struct.</p><p>In particular, does the following:</p><ol><li>Initializes an embedder object</li><li>Creates a SQLite databse with the corpus name. It should have:</li></ol><ul><li>row-wise primary key uuid</li><li>doc_name representing the <em>parent</em> document</li><li>chunk text </li></ul><p>We can add more metadata later, if desired</p><p><strong>Parameters</strong></p><p>corpus<em>name : str or nothing     the name that you want to give the database     optional. if left as nothing, we use an in-memory database embedder</em>model<em>path : str     a path to a HuggingFace-hosted model     e.g. &quot;BAAI/bge-small-en-v1.5&quot; max</em>seq_len : int     The maximum number of tokens per chunk.     This should be the max sequence length of the tokenizer</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Juissie-GW/Juissie.jl/blob/15e686ea43ed50150619b8fe99cf4f4d60cabbe5/src/SemanticSearch/Backend.jl#L75-L99">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Juissie.Generation.SemanticSearch.Backend.index-Tuple{Juissie.Generation.SemanticSearch.Backend.Corpus}" href="#Juissie.Generation.SemanticSearch.Backend.index-Tuple{Juissie.Generation.SemanticSearch.Backend.Corpus}"><code>Juissie.Generation.SemanticSearch.Backend.index</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function index(corpus::Corpus)</code></pre><p>Constructs the HNSW vector index from the data available. If the corpus has a corpus_name, then we also save the new index to disk. Must be run before searching.</p><p><strong>Parameters</strong></p><p>corpus : an initialized Corpus object     the corpus / &quot;vector database&quot; you want to use</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Juissie-GW/Juissie.jl/blob/15e686ea43ed50150619b8fe99cf4f4d60cabbe5/src/SemanticSearch/Backend.jl#L398-L409">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Juissie.Generation.SemanticSearch.Backend.load_corpus-Tuple{String}" href="#Juissie.Generation.SemanticSearch.Backend.load_corpus-Tuple{String}"><code>Juissie.Generation.SemanticSearch.Backend.load_corpus</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function load_corpus(corpus_name)</code></pre><p>Loads an already-initialized corpus from its associated &quot;artifacts&quot; (relational database, vector index, and informational json).</p><p><strong>Parameters</strong></p><p>corpus_name : str     the name of your EXISTING vector database</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Juissie-GW/Juissie.jl/blob/15e686ea43ed50150619b8fe99cf4f4d60cabbe5/src/SemanticSearch/Backend.jl#L163-L173">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Juissie.Generation.SemanticSearch.Backend.search" href="#Juissie.Generation.SemanticSearch.Backend.search"><code>Juissie.Generation.SemanticSearch.Backend.search</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">function search(corpus::Corpus, query::String, k::Int=5)</code></pre><p>Performs approximate nearest neighbor search to find the items in the vector index closest to the query.</p><p><strong>Parameters</strong></p><p>corpus : an initialized Corpus object     the corpus / &quot;vector database&quot; you want to use query : str     The text you want to search, e.g. your question     We embed this and perform semantic retrieval against the vector db k : int     The number of nearest-neighbor vectors to fetch</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Juissie-GW/Juissie.jl/blob/15e686ea43ed50150619b8fe99cf4f4d60cabbe5/src/SemanticSearch/Backend.jl#L432-L447">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Juissie.Generation.SemanticSearch.Backend.upsert_chunk-Tuple{Juissie.Generation.SemanticSearch.Backend.Corpus, String, String}" href="#Juissie.Generation.SemanticSearch.Backend.upsert_chunk-Tuple{Juissie.Generation.SemanticSearch.Backend.Corpus, String, String}"><code>Juissie.Generation.SemanticSearch.Backend.upsert_chunk</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function upsert_chunk(corpus::Corpus, chunk::String, doc_name::String)</code></pre><p>Given a new chunk of text, get embedding and insert into our vector DB. Not actually a full upsert, because we have to reindex later. Process:</p><ol><li>Generate an embedding for the text</li><li>Insert metadata into database</li><li>Increment idx counter</li></ol><p><strong>Parameters</strong></p><p>corpus : an initialized Corpus object     the corpus / &quot;vector database&quot; you want to use chunk : str     This is the text content of the chunk you want to upsert doc<em>name : str     The name of the document that chunk is from. For instance, if you      were upserting all the chunks in an academic paper, doc</em>name might     be the name of that paper</p><p><strong>Notes</strong></p><p>If the vectors have been indexed, this de-indexes them (i.e., they need to be indexed again). Currently, we handle this by setting hnsw to  nothing so that it gets caught later in search.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Juissie-GW/Juissie.jl/blob/15e686ea43ed50150619b8fe99cf4f4d60cabbe5/src/SemanticSearch/Backend.jl#L239-L265">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Juissie.Generation.SemanticSearch.Backend.upsert_document-Tuple{Juissie.Generation.SemanticSearch.Backend.Corpus, String, String}" href="#Juissie.Generation.SemanticSearch.Backend.upsert_document-Tuple{Juissie.Generation.SemanticSearch.Backend.Corpus, String, String}"><code>Juissie.Generation.SemanticSearch.Backend.upsert_document</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function upsert_document(corpus::Corpus, doc_text::String, doc_name::String)</code></pre><p>Upsert a whole document (i.e., long string). Does so by splitting the document into appropriately-sized chunks so no chunk exceeds the embedder&#39;s tokenization max sequence length, while prioritizing sentence endings.</p><p><strong>Parameters</strong></p><p>corpus : an initialized Corpus object     the corpus / &quot;vector database&quot; you want to use doc<em>text : str     A long string you want to upsert. We will break this into chunks and     upsert each chunk. doc</em>name : str     The name of the document the content is from</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Juissie-GW/Juissie.jl/blob/15e686ea43ed50150619b8fe99cf4f4d60cabbe5/src/SemanticSearch/Backend.jl#L287-L303">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Juissie.Generation.SemanticSearch.Backend.upsert_document-Tuple{Juissie.Generation.SemanticSearch.Backend.Corpus, Vector{String}, String}" href="#Juissie.Generation.SemanticSearch.Backend.upsert_document-Tuple{Juissie.Generation.SemanticSearch.Backend.Corpus, Vector{String}, String}"><code>Juissie.Generation.SemanticSearch.Backend.upsert_document</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function upsert_document(corpus::Corpus, documents::Vector{String}, doc_name::String)</code></pre><p>Upsert a collection of documents (i.e., a vector of long strings). Does so by upserting each entry of the provided documents vector (which in turn will chunkify, each document further into appropriately sized chunks).</p><p>See the upsert_document(...) above for more details</p><p><strong>Parameters</strong></p><p>corpus : an initialized Corpus object     the corpus / &quot;vector database&quot; you want to use documents : Vector{String}     a collection of long strings to upsert. doc_name : str     The name of the document the content is from</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Juissie-GW/Juissie.jl/blob/15e686ea43ed50150619b8fe99cf4f4d60cabbe5/src/SemanticSearch/Backend.jl#L311-L328">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Juissie.Generation.SemanticSearch.Backend.upsert_document_from_pdf-Tuple{Juissie.Generation.SemanticSearch.Backend.Corpus, String, String}" href="#Juissie.Generation.SemanticSearch.Backend.upsert_document_from_pdf-Tuple{Juissie.Generation.SemanticSearch.Backend.Corpus, String, String}"><code>Juissie.Generation.SemanticSearch.Backend.upsert_document_from_pdf</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function upsert_document_from_pdf(corpus::Corpus, filePath::String, doc_name::String)</code></pre><p>Upsert all the data in a PDF file into the provided corpus. See the upsert_document(...) above for more details.</p><p><strong>Parameters</strong></p><p>corpus : an initialized Corpus object     the corpus / &quot;vector database&quot; you want to use filePath : String     The path to the PDF file to read doc_name : str     The name of the document the content is from</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Juissie-GW/Juissie.jl/blob/15e686ea43ed50150619b8fe99cf4f4d60cabbe5/src/SemanticSearch/Backend.jl#L361-L375">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Juissie.Generation.SemanticSearch.Backend.upsert_document_from_txt-Tuple{Juissie.Generation.SemanticSearch.Backend.Corpus, String, String}" href="#Juissie.Generation.SemanticSearch.Backend.upsert_document_from_txt-Tuple{Juissie.Generation.SemanticSearch.Backend.Corpus, String, String}"><code>Juissie.Generation.SemanticSearch.Backend.upsert_document_from_txt</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function upsert_document_from_txt(corpus::Corpus, filePath::String, doc_name::String)</code></pre><p>Upsert all the data from the text file into the provided corpus.</p><p><strong>Parameters</strong></p><p>corpus : an initialized Corpus object     the corpus / &quot;vector database&quot; you want to use filePath : String     The path to the txt file to read doc_name : str     The name of the document the content is from</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Juissie-GW/Juissie.jl/blob/15e686ea43ed50150619b8fe99cf4f4d60cabbe5/src/SemanticSearch/Backend.jl#L380-L393">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Juissie.Generation.SemanticSearch.Backend.upsert_document_from_url" href="#Juissie.Generation.SemanticSearch.Backend.upsert_document_from_url"><code>Juissie.Generation.SemanticSearch.Backend.upsert_document_from_url</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">function upsert_document_from_url(corpus::Corpus, url::String, doc_name::String, elements::Array{String}=[&quot;h1&quot;, &quot;h2&quot;, &quot;p&quot;])</code></pre><p>Extracts element-tagged text from HTML and upserts as a document.</p><p><strong>Parameters</strong></p><p>corpus : an initialized Corpus object     the corpus / &quot;vector database&quot; you want to use url : String     The url you want to scrape for text doc_name : str     The name of the document the content is from elements : Array{String}     A list of HTML elements you want to pull the text from</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Juissie-GW/Juissie.jl/blob/15e686ea43ed50150619b8fe99cf4f4d60cabbe5/src/SemanticSearch/Backend.jl#L335-L350">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Juissie.Generation.SemanticSearch.Backend.Corpus" href="#Juissie.Generation.SemanticSearch.Backend.Corpus"><code>Juissie.Generation.SemanticSearch.Backend.Corpus</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Corpus</code></pre><p>Basically a vector database. It will have these attributes:</p><ol><li>a relational database (SQLite)</li><li>a vector index (HNSW)</li><li>an embedder (via Embedding.jl)</li></ol><p><strong>Attributes</strong></p><p>corpus<em>name : String or Nothing     this is the name of your corpus and will be used to access saved          corpuses     if Nothing, we can&#39;t save/load and everything will be in-memory db : a SQLite.DB connection object     this is a real relational database to store metadata (e.g. chunk text, doc name) hnsw : Hierarchical Navigable Small World object     this is our searchable vector index embedder : Embedder     an initialized Embedder struct max</em>seq<em>len : int     The maximum number of tokens per chunk.     This should be the max sequence length of the tokenizer data : Vector{Any}     The embeddings get stored here before we create the vector index next</em>idx : int     stores the index we&#39;ll use for the next-upserted chunk</p><p><strong>Notes</strong></p><p>The struct is mutable because we want to be able to change things like incrementing next_idx.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Juissie-GW/Juissie.jl/blob/15e686ea43ed50150619b8fe99cf4f4d60cabbe5/src/SemanticSearch/Backend.jl#L32-L64">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Juissie.Generation.SemanticSearch.Backend.Corpus" href="#Juissie.Generation.SemanticSearch.Backend.Corpus"><code>Juissie.Generation.SemanticSearch.Backend.Corpus</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">function Corpus(corpus_name::String, embedder_model_path::String=&quot;BAAI/bge-small-en-v1.5&quot;)</code></pre><p>Initializes a Corpus struct.</p><p>In particular, does the following:</p><ol><li>Initializes an embedder object</li><li>Creates a SQLite databse with the corpus name. It should have:</li></ol><ul><li>row-wise primary key uuid</li><li>doc_name representing the <em>parent</em> document</li><li>chunk text </li></ul><p>We can add more metadata later, if desired</p><p><strong>Parameters</strong></p><p>corpus<em>name : str or nothing     the name that you want to give the database     optional. if left as nothing, we use an in-memory database embedder</em>model<em>path : str     a path to a HuggingFace-hosted model     e.g. &quot;BAAI/bge-small-en-v1.5&quot; max</em>seq_len : int     The maximum number of tokens per chunk.     This should be the max sequence length of the tokenizer</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Juissie-GW/Juissie.jl/blob/15e686ea43ed50150619b8fe99cf4f4d60cabbe5/src/SemanticSearch/Backend.jl#L75-L99">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Juissie.Generation.SemanticSearch.Backend.TextUtils.chunkify" href="#Juissie.Generation.SemanticSearch.Backend.TextUtils.chunkify"><code>Juissie.Generation.SemanticSearch.Backend.TextUtils.chunkify</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">function chunkify(text::String, tokenizer, sequence_length::Int=512)</code></pre><p>Splits a provided text (e.g. paragraph) into chunks that are each as many sentences as possible while keeping the chunk&#39;s token lenght below the sequence_length. This ensures that each chunk can be fully encoded by the embedder.</p><p><strong>Parameters</strong></p><p>text : String     The text you want to split into chunks. tokenizer : a tokenizer object, e.g. BertTextEncoder     The tokenizer you will be using sequence_length : Int     The maximum number of tokens per chunk.     Ideally, should correspond to the max sequence length of the tokenizer</p><p><strong>Example Usage</strong></p><pre><code class="nohighlight hljs">&gt;&gt;&gt; chunkify(
    &#39;&#39;&#39;Hold me closer, tiny dancer. Count the headlights on the highway. Lay me down in sheets of linen. Peter Piper picked a peck of pickled peppers. A peck of pickled peppers Peter Piper picked.
    &#39;&#39;&#39;, 
    corpus.embedder.tokenizer, 
    20
)

4-element Vector{Any}:
&quot;Hold me closer, tiny dancer. Count the headlights on the highway.&quot;
&quot;Lay me down in sheets of linen.&quot;
&quot;Peter Piper picked a peck of pickled peppers.&quot;
&quot;A peck of pickled peppers Peter Piper picked.&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Juissie-GW/Juissie.jl/blob/15e686ea43ed50150619b8fe99cf4f4d60cabbe5/src/SemanticSearch/TextUtils.jl#L81-L112">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Juissie.Generation.SemanticSearch.Backend.TextUtils.get_files_path-Tuple{}" href="#Juissie.Generation.SemanticSearch.Backend.TextUtils.get_files_path-Tuple{}"><code>Juissie.Generation.SemanticSearch.Backend.TextUtils.get_files_path</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function get_files_path()</code></pre><p>Simple function to return the path to the files subdirectory.</p><p><strong>Example Usage</strong></p><p>test<em>bin</em>path = get<em>files</em>path()*&quot;test.bin&quot;</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Juissie-GW/Juissie.jl/blob/15e686ea43ed50150619b8fe99cf4f4d60cabbe5/src/SemanticSearch/TextUtils.jl#L13-L21">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Juissie.Generation.SemanticSearch.Backend.TextUtils.read_html_url" href="#Juissie.Generation.SemanticSearch.Backend.TextUtils.read_html_url"><code>Juissie.Generation.SemanticSearch.Backend.TextUtils.read_html_url</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">read_html_url(url::String, elements::Array{String})</code></pre><p>Returns a string of text from the provided HTML elements on a webpage.</p><p><strong>Parameters</strong></p><p>url : String     the url you want to read elements : Array{String}     html elements to look for in the web page, e.g. [&quot;h1&quot;, &quot;p&quot;].</p><p><strong>Notes</strong></p><p>Defaults to extracting headers and paragraphs</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Juissie-GW/Juissie.jl/blob/15e686ea43ed50150619b8fe99cf4f4d60cabbe5/src/SemanticSearch/TextUtils.jl#L27-L42">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Juissie.Generation.SemanticSearch.Backend.TextUtils.sentence_splitter-Tuple{String}" href="#Juissie.Generation.SemanticSearch.Backend.TextUtils.sentence_splitter-Tuple{String}"><code>Juissie.Generation.SemanticSearch.Backend.TextUtils.sentence_splitter</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function sentence_splitter(text::String)</code></pre><p>Uses basic regex to divide a provided text (e.g. paragraph) into sentences.</p><p><strong>Parameters</strong></p><p>text : String     The text you want to split into sentences.</p><p><strong>Notes</strong></p><p>Regex is hard to read. The first part looks for spaces following  end-of-sentence punctuation. The second part matches at the end of the string.</p><p>Regex in Julia uses an r identifier prefix.</p><p><strong>References</strong></p><p>https://www.geeksforgeeks.org/regular-expressions-in-julia/</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Juissie-GW/Juissie.jl/blob/15e686ea43ed50150619b8fe99cf4f4d60cabbe5/src/SemanticSearch/TextUtils.jl#L54-L74">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Juissie.SemanticSearch.Backend.TxtReader.appendToFile-Tuple{String, String}" href="#Juissie.SemanticSearch.Backend.TxtReader.appendToFile-Tuple{String, String}"><code>Juissie.SemanticSearch.Backend.TxtReader.appendToFile</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Append the given <code>contents</code> into a file specified at <code>filename</code>. A new file will be created if <code>filename</code> doesn&#39;t already exist.</p><p>NOTE: No &#39; &#39; newline character will be appended. It is the  caller&#39;s responsibility to decide if the <code>contents</code> should have a &#39; &#39; newline character or not. </p><p><strong>Parameters</strong></p><p>filename: String     The name of the file to open. Relative file paths are evaluated from     the directory where the <code>julia</code> command was run. Typically the root level     of the project contents: String     The exact text to append into the file.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Juissie-GW/Juissie.jl/blob/15e686ea43ed50150619b8fe99cf4f4d60cabbe5/src/SemanticSearch/DataReader/TxtReader.jl#L85-L103">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Juissie.SemanticSearch.Backend.TxtReader.getAllTextInFile-Tuple{String}" href="#Juissie.SemanticSearch.Backend.TxtReader.getAllTextInFile-Tuple{String}"><code>Juissie.SemanticSearch.Backend.TxtReader.getAllTextInFile</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Open the provided filename, load all the data into memory, and return. This function will also manage the file socket open(...) close(...) properly. If there was an error in opening or reading the file then the empty  string will be returned</p><p><strong>Parameters</strong></p><p>filename: String     The name of the file to open. Relative file paths are evaluated from     the directory where the <code>julia</code> command was run. Typically the root level     of the project</p><p>Returns: String     The entire contets of the file, or an empty string if there was an issue</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Juissie-GW/Juissie.jl/blob/15e686ea43ed50150619b8fe99cf4f4d60cabbe5/src/SemanticSearch/DataReader/TxtReader.jl#L55-L70">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Juissie.SemanticSearch.Backend.TxtReader.splitFileIntoParts-Tuple{String, String, Int64}" href="#Juissie.SemanticSearch.Backend.TxtReader.splitFileIntoParts-Tuple{String, String, Int64}"><code>Juissie.SemanticSearch.Backend.TxtReader.splitFileIntoParts</code></a> — <span class="docstring-category">Method</span></header><section><div><p>A simple script that allows a user to split a large file into multiple smaller files.  This will create splits # of children files, each with a file size ~1/splits  of the origional target file.</p><p><strong>Parameters</strong></p><p>fileToSplit : String     The name of the file to read and split into multiple parts.     If an absolute file path is given then that will be     used. Otherwise, relative file paths are evaluated from the location that     the <code>julia</code> command was run from (typically the root level of this project) outputFileNameBase : String     The template for the name of the children split-out files.      Each split out file with have the format of &lt;outputFileNameBase&gt;_&lt;#&gt;      where # starts at 1 and increments by 1 for each subsequent file.      There will be <code>splits</code> number of children files splits : Int     How many children files should be created?</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Juissie-GW/Juissie.jl/blob/15e686ea43ed50150619b8fe99cf4f4d60cabbe5/src/SemanticSearch/DataReader/TxtReader.jl#L6-L25">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Juissie.Generation.build_full_query" href="#Juissie.Generation.build_full_query"><code>Juissie.Generation.build_full_query</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">function build_full_query(query::String, context::OptionalContext=nothing)</code></pre><p>Given a query and a list of contextual chunks, construct a full query incorporating both.</p><p><strong>Parameters</strong></p><p>query : String     the main instruction or query string context : OptionalContext, which is Union{Vector{String}, Nothing}     optional list of chunks providing additional context for the query</p><p><strong>Notes</strong></p><p>We use the Alpaca prompt, found here: https://github.com/tatsu-lab/stanford_alpaca with minor modifications that reflect our response preferences.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Juissie-GW/Juissie.jl/blob/15e686ea43ed50150619b8fe99cf4f4d60cabbe5/src/Generation.jl#L247-L264">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Juissie.Generation.check_oai_key_format-Tuple{String}" href="#Juissie.Generation.check_oai_key_format-Tuple{String}"><code>Juissie.Generation.check_oai_key_format</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function check_oai_key_format(key::String)</code></pre><p>Uses regex to check if a provided string is in the expected format of an OpenAI     API Key</p><p><strong>Parameters</strong></p><p>key : String     the key you want to check</p><p><strong>Notes</strong></p><p>See here for more on the regex:</p><ul><li>https://en.wikibooks.org/wiki/Introducing<em>Julia/Strings</em>and<em>characters#Finding</em>and<em>replacing</em>things<em>inside</em>strings</li></ul><p>Uses format rule provided here:</p><ul><li>https://github.com/secretlint/secretlint/issues/676</li><li>https://community.openai.com/t/what-are-the-valid-characters-for-the-apikey/288643</li></ul><p>Note that this only checks the key format, not whether the key is valid or has not  been revoked.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Juissie-GW/Juissie.jl/blob/15e686ea43ed50150619b8fe99cf4f4d60cabbe5/src/Generation.jl#L28-L50">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Juissie.Generation.generate" href="#Juissie.Generation.generate"><code>Juissie.Generation.generate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">generate(generator::Union{OAIGenerator, Nothing}, query::String, context::OptionalContext=nothing, temperature::Float64=0.7)</code></pre><p>Generate a response based on a given query and optional context using the specified OAIGenerator. This function constructs a full query, sends it to the OpenAI API, and returns the generated response.</p><p><strong>Parameters</strong></p><p>generator : Union{OAIGenerator, Nothing}     an initialized generator (e..g OAIGenerator)     leaving this as a union with nothing to note that we may want to support other      generator types in the future (e.g. HFGenerator, etc.) query : String     the main query string. This is basically your question context : OptionalContext, which is Union{Vector{String}, Nothing}     optional list of contextual chunk strings to provide the generator additional      context for the query. Ultimately, these will be coming from our vector DB temperature : Float64     controls the stochasticity of the output generated by the model</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Juissie-GW/Juissie.jl/blob/15e686ea43ed50150619b8fe99cf4f4d60cabbe5/src/Generation.jl#L300-L318">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Juissie.Generation.generate_with_corpus" href="#Juissie.Generation.generate_with_corpus"><code>Juissie.Generation.generate_with_corpus</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">function generate_with_corpus(generator::Union{OAIGenerator, Nothing}, corpus::Corpus, query::String, k::Int=5, temperature::Float64=0.7)</code></pre><p><strong>Parameters</strong></p><p>generator : Union{OAIGenerator, Nothing}     an initialized generator (e..g OAIGenerator)     leaving this as a union with nothing to note that we may want to support other      generator types in the future (e.g. HFGenerator, etc.) corpus : an initialized Corpus object     the corpus / &quot;vector database&quot; you want to use query : String     the main instruction or query string. This is basically your question k : int     The number of nearest-neighbor vectors to fetch from the corpus to build your context temperature : Float64     controls the stochasticity of the output generated by the model</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Juissie-GW/Juissie.jl/blob/15e686ea43ed50150619b8fe99cf4f4d60cabbe5/src/Generation.jl#L350-L367">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Juissie.Generation.load_OAIGeneratorWithCorpus" href="#Juissie.Generation.load_OAIGeneratorWithCorpus"><code>Juissie.Generation.load_OAIGeneratorWithCorpus</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">function load_OAIGeneratorWithCorpus(corpus_name::String, auth_token::Union{String, Nothing}=nothing)</code></pre><p>Loads an existing corpus and uses it to initialize an GeneratorWithCorpus</p><p><strong>Parameters</strong></p><p>corpus<em>name : str     the name that you want to give the database auth</em>token :: Union{String, Nothing}     this is your OPENAI API key. You can either pass it explicitly as a string     or leave this argument as nothing. In the latter case, we will look in your     environmental variables for &quot;OAI_KEY&quot;</p><p><strong>Notes</strong></p><p>corpus<em>name is ordered first because Julia uses positional arguments and  auth</em>token is optional.</p><p>When instantiating a new OAIGenerator in an externally-viewable setting (e.g. notebooks committed to GitHub or a public demo), it is important to place a semicolon after the command, e.g.  &#39;&#39;&#39;generator=load<em>OAIGeneratorWithCorpus(&quot;greek</em>philosophers&quot;);&#39;&#39;&#39; to ensure that your OAI API key is not inadvertently shared.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Juissie-GW/Juissie.jl/blob/15e686ea43ed50150619b8fe99cf4f4d60cabbe5/src/Generation.jl#L206-L230">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Juissie.Generation.upsert_chunk_to_generator-Tuple{Juissie.Generation.GeneratorWithCorpus, String, String}" href="#Juissie.Generation.upsert_chunk_to_generator-Tuple{Juissie.Generation.GeneratorWithCorpus, String, String}"><code>Juissie.Generation.upsert_chunk_to_generator</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function upsert_chunk_to_generator(generator::GeneratorWithCorpus, chunk::String, doc_name::String)</code></pre><p>Equivalent to Backend.upsert_chunk, but takes a GeneratorWithCorpus instead of a Corpus.</p><p><strong>Parameters</strong></p><p>generator : any struct that subtypes GeneratorWithCorpus     the generator (with corpus) you want to use chunk : str     This is the text content of the chunk you want to upsert doc<em>name : str     The name of the document that chunk is from. For instance, if you      were upserting all the chunks in an academic paper, doc</em>name might     be the name of that paper</p><p><strong>Notes</strong></p><p>One would expect Julia&#39;s multiple dispatch to allow us to call this upsert<em>chunk, but not so. The conflict arises in Juissie, where  we would have both SemanticSearch and Generation exporting  upsert</em>chunk. This means any uses of it in Juissie must be  qualified, and without doing so, neither actually gets defined.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Juissie-GW/Juissie.jl/blob/15e686ea43ed50150619b8fe99cf4f4d60cabbe5/src/Generation.jl#L379-L403">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Juissie.Generation.upsert_document_from_url_to_generator" href="#Juissie.Generation.upsert_document_from_url_to_generator"><code>Juissie.Generation.upsert_document_from_url_to_generator</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">function upsert_document_from_url_to_generator(generator::GeneratorWithCorpus, url::String, doc_name::String, elements::Array{String}=[&quot;h1&quot;, &quot;h2&quot;, &quot;p&quot;])</code></pre><p>Equivalent to Backend.upsert<em>document</em>from_url, but takes a  GeneratorWithCorpus instead of a Corpus.</p><p><strong>Parameters</strong></p><p>generator : any struct that subtypes GeneratorWithCorpus     the generator (with corpus) you want to use url : String     The url you want to scrape for text doc_name : str     The name of the document the content is from elements : Array{String}     A list of HTML elements you want to pull the text from</p><p><strong>Notes</strong></p><p>See note for upsert<em>chunk</em>to_generator - same idea.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Juissie-GW/Juissie.jl/blob/15e686ea43ed50150619b8fe99cf4f4d60cabbe5/src/Generation.jl#L440-L460">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Juissie.Generation.upsert_document_to_generator-Tuple{Juissie.Generation.GeneratorWithCorpus, String, String}" href="#Juissie.Generation.upsert_document_to_generator-Tuple{Juissie.Generation.GeneratorWithCorpus, String, String}"><code>Juissie.Generation.upsert_document_to_generator</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function upsert_document_to_generator(generator::GeneratorWithCorpus, doc_text::String, doc_name::String)</code></pre><p>Equivalent to Backend.upsert_document, but takes a GeneratorWithCorpus instead of a Corpus.</p><p><strong>Parameters</strong></p><p>generator : any struct that subtypes GeneratorWithCorpus     the generator (with corpus) you want to use doc<em>text : str     A long string you want to upsert. We will break this into chunks and     upsert each chunk. doc</em>name : str     The name of the document the content is from</p><p><strong>Notes</strong></p><p>See note for upsert<em>chunk</em>to_generator - same idea.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Juissie-GW/Juissie.jl/blob/15e686ea43ed50150619b8fe99cf4f4d60cabbe5/src/Generation.jl#L412-L431">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Juissie.Generation.OAIGenerator" href="#Juissie.Generation.OAIGenerator"><code>Juissie.Generation.OAIGenerator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">function OAIGenerator(auth_token::Union{String, Nothing})</code></pre><p>Initializes an OAIGenerator struct.</p><p><strong>Parameters</strong></p><p>auth<em>token :: Union{String, Nothing}     this is your OPENAI API key. You can either pass it explicitly as a string     or leave this argument as nothing. In the latter case, we will look in your     environmental variables for &quot;OAI</em>KEY&quot;</p><p><strong>Notes</strong></p><p>When instantiating a new OAIGenerator in an externally-viewable setting (e.g. notebooks committed to GitHub or a public demo), it is important to place a semicolon after the command, e.g.  &#39;&#39;&#39;generator=load<em>OAIGeneratorWithCorpus(&quot;greek</em>philosophers&quot;);&#39;&#39;&#39; to ensure that your OAI API key is not inadvertently shared.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Juissie-GW/Juissie.jl/blob/15e686ea43ed50150619b8fe99cf4f4d60cabbe5/src/Generation.jl#L123-L142">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Juissie.Generation.OAIGenerator" href="#Juissie.Generation.OAIGenerator"><code>Juissie.Generation.OAIGenerator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct OAIGenerator</code></pre><p>A struct for handling natural language generation via OpenAI&#39;s gpt-3.5-turbo completion endpoint.</p><p><strong>Attributes</strong></p><p>url : String     the URL of the OpenAI API endpoint header : Vector{Pair{String, String}}     key-value pairs representing the HTTP headers for the request body : Dict{String, Any}     this is the JSON payload to be sent in the body of the request</p><p><strong>Notes</strong></p><p>All natural language generation should be done via a &quot;Generator&quot; object of some kind for consistency. In the future, if we  decide to host a model locally or something, we might do that via a HFGenerator struct.</p><p>When instantiating a new OAIGenerator in an externally-viewable setting (e.g. notebooks committed to GitHub or a public demo), it is important to place a semicolon after the command, e.g.  &#39;&#39;&#39;generator=load<em>OAIGeneratorWithCorpus(&quot;greek</em>philosophers&quot;);&#39;&#39;&#39; to ensure that your OAI API key is not inadvertently shared.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Juissie-GW/Juissie.jl/blob/15e686ea43ed50150619b8fe99cf4f4d60cabbe5/src/Generation.jl#L56-L83">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Juissie.Generation.OAIGeneratorWithCorpus" href="#Juissie.Generation.OAIGeneratorWithCorpus"><code>Juissie.Generation.OAIGeneratorWithCorpus</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">function OAIGeneratorWithCorpus(auth_token::Union{String, Nothing}=nothing, corpus::Corpus)</code></pre><p>Initializes an OAIGeneratorWithCorpus.</p><p><strong>Parameters</strong></p><p>corpus<em>name : str or nothing     the name that you want to give the database     optional. if left as nothing, we use an in-memory database auth</em>token :: Union{String, Nothing}     this is your OPENAI API key. You can either pass it explicitly as a string     or leave this argument as nothing. In the latter case, we will look in your     environmental variables for &quot;OAI<em>KEY&quot; embedder</em>model<em>path : str     a path to a HuggingFace-hosted model     e.g. &quot;BAAI/bge-small-en-v1.5&quot; max</em>seq_len : int     The maximum number of tokens per chunk.     This should be the max sequence length of the tokenizer</p><p><strong>Notes</strong></p><p>When instantiating a new OAIGenerator in an externally-viewable setting (e.g. notebooks committed to GitHub or a public demo), it is important to place a semicolon after the command, e.g.  &#39;&#39;&#39;generator=load<em>OAIGeneratorWithCorpus(&quot;greek</em>philosophers&quot;);&#39;&#39;&#39; to ensure that your OAI API key is not inadvertently shared.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Juissie-GW/Juissie.jl/blob/15e686ea43ed50150619b8fe99cf4f4d60cabbe5/src/Generation.jl#L160-L188">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Juissie.Generation.OAIGeneratorWithCorpus" href="#Juissie.Generation.OAIGeneratorWithCorpus"><code>Juissie.Generation.OAIGeneratorWithCorpus</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct OAIGeneratorWithCorpus</code></pre><p>Like OAIGenerator, but has a corpus attached.</p><p><strong>Attributes</strong></p><p>url : String     the URL of the OpenAI API endpoint header : Vector{Pair{String, String}}     key-value pairs representing the HTTP headers for the request body : Dict{String, Any}     this is the JSON payload to be sent in the body of the request corpus : an initialized Corpus object     the corpus / &quot;vector database&quot; you want to use</p><p><strong>Notes</strong></p><p>When instantiating a new OAIGenerator in an externally-viewable setting (e.g. notebooks committed to GitHub or a public demo), it is important to place a semicolon after the command, e.g.  &#39;&#39;&#39;generator=load<em>OAIGeneratorWithCorpus(&quot;greek</em>philosophers&quot;);&#39;&#39;&#39; to ensure that your OAI API key is not inadvertently shared.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Juissie-GW/Juissie.jl/blob/15e686ea43ed50150619b8fe99cf4f4d60cabbe5/src/Generation.jl#L91-L114">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Juissie.SemanticSearch.Backend.PdfReader.bufferToString!-Tuple{IOBuffer}" href="#Juissie.SemanticSearch.Backend.PdfReader.bufferToString!-Tuple{IOBuffer}"><code>Juissie.SemanticSearch.Backend.PdfReader.bufferToString!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Extract the contents of the buffer and convert it into a string object</code></pre><p>WARNING: This function will clear out the contents of the buffer</p><p><strong>Parameters</strong></p><p>buff : The buffer to clear, it&#39;s contents will be returned as a string</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Juissie-GW/Juissie.jl/blob/15e686ea43ed50150619b8fe99cf4f4d60cabbe5/src/SemanticSearch/DataReader/PdfReader.jl#L150-L157">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Juissie.SemanticSearch.Backend.PdfReader.getAllTextInPDF" href="#Juissie.SemanticSearch.Backend.PdfReader.getAllTextInPDF"><code>Juissie.SemanticSearch.Backend.PdfReader.getAllTextInPDF</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Extract all the text data from the provided pdf file.</code></pre><p>Open the pdf at the provided file location, extract all the text data from it (as far as possible), and return that text data as a vector of strings. Each entry in the rsult vector is the appended sum of some number of pages in the PDF. 100 Pages per entry is default. For example, the getAllTextInPDF(...)[0] will be a  long string containing 100 pages worth of data. The next entry represents the next 100  pages, etc.</p><p>NOTE: This function is a &quot;best effort&quot; function, meaning that it will try to extract as many pages as it can. But if there are pages that are invalid, or otherwise can not be properly parsed then they will simply be ignored and not included in the  returned strings.</p><p><strong>Parameters</strong></p><p>fileLocation : The full path to the PDF file to open. This should be relative from where the <code>julia</code> command has been run (not relative to this source file)</p><p>pagesPerEntry : How many pages should be collected into the buffere before turning it into an entry in the result vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Juissie-GW/Juissie.jl/blob/15e686ea43ed50150619b8fe99cf4f4d60cabbe5/src/SemanticSearch/DataReader/PdfReader.jl#L9-L30">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Juissie.SemanticSearch.Backend.PdfReader.getPagesFromPdf-Tuple{PDFIO.PD.PDDocImpl, Number, Number}" href="#Juissie.SemanticSearch.Backend.PdfReader.getPagesFromPdf-Tuple{PDFIO.PD.PDDocImpl, Number, Number}"><code>Juissie.SemanticSearch.Backend.PdfReader.getPagesFromPdf</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Collect and return all the text data found in the pdf file found in the provided page range.</code></pre><p>Using the provided PDF Handel, loop over all the pages in the range and attempt to extract the text data. All the collected data will be returned.</p><p>The specific pages to read are defined by [firstPageInclusive, lastPageInclusive] which (naturally) defines an inclusive range. Meaning the first and last page number will be included in the returned string. These ranges SHOULD be valid (ie, in the range [1, MaxPageCount]) but error checking will coerce the values to a proper range.</p><p><strong>Parameters</strong></p><p>pdfHandel : The PDF file to extract data from firstPageInclusive : The first page in the range to read lastPageInclusive : The last page in the range to read</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Juissie-GW/Juissie.jl/blob/15e686ea43ed50150619b8fe99cf4f4d60cabbe5/src/SemanticSearch/DataReader/PdfReader.jl#L75-L92">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Juissie.SemanticSearch.Backend.PdfReader.getPagesFromPdf-Tuple{String, Number, Number}" href="#Juissie.SemanticSearch.Backend.PdfReader.getPagesFromPdf-Tuple{String, Number, Number}"><code>Juissie.SemanticSearch.Backend.PdfReader.getPagesFromPdf</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Collect and return all the text data found in the pdf file found in the provided page range.</code></pre><p>Using the provided file path, open the PDF and loop over all the pages in the range and attempt to extract the text data. All the collected data will be returned.</p><p>The specific pages to read are defined by [firstPageInclusive, lastPageInclusive] which (naturally) defines an inclusive range. Meaning the first and last page number will be included in the returned string. These ranges SHOULD be valid (ie, in the range [1, MaxPageCount]) but error checking will coerce the values to a proper range.</p><p><strong>Parameters</strong></p><p>fileLocation : The location of the PDF to read firstPageInclusive : The first page in the range to read lastPageInclusive : The last page in the range to read</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Juissie-GW/Juissie.jl/blob/15e686ea43ed50150619b8fe99cf4f4d60cabbe5/src/SemanticSearch/DataReader/PdfReader.jl#L47-L64">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Juissie.SemanticSearch.Backend.PdfReader.getPagesInPDF_All-Tuple{String}" href="#Juissie.SemanticSearch.Backend.PdfReader.getPagesInPDF_All-Tuple{String}"><code>Juissie.SemanticSearch.Backend.PdfReader.getPagesInPDF_All</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Extract all the text data from the provided pdf file.</code></pre><p>Open the pdf at the provided file location, extract all the text data from it (as far as possible), and return that text data as a vector of strings. Each entry in the result vector is the data from a single page of the PDF file.</p><p>NOTE: This function is a &quot;best effort&quot; function, meaning that it will try to extract as many pages as it can. But if there are pages that are invalid, or otherwise can not be properly parsed then they will simply be ignored and not included in the  returned strings.</p><p><strong>Parameters</strong></p><p>fileLocation : The full path to the PDF file to open. This should be relative from where the <code>julia</code> command has been run (not relative to this source file)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Juissie-GW/Juissie.jl/blob/15e686ea43ed50150619b8fe99cf4f4d60cabbe5/src/SemanticSearch/DataReader/PdfReader.jl#L130-L145">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Juissie.Generation.SemanticSearch.Backend.TxtReader.appendToFile-Tuple{String, String}" href="#Juissie.Generation.SemanticSearch.Backend.TxtReader.appendToFile-Tuple{String, String}"><code>Juissie.Generation.SemanticSearch.Backend.TxtReader.appendToFile</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Append the given <code>contents</code> into a file specified at <code>filename</code>. A new file will be created if <code>filename</code> doesn&#39;t already exist.</p><p>NOTE: No &#39; &#39; newline character will be appended. It is the  caller&#39;s responsibility to decide if the <code>contents</code> should have a &#39; &#39; newline character or not. </p><p><strong>Parameters</strong></p><p>filename: String     The name of the file to open. Relative file paths are evaluated from     the directory where the <code>julia</code> command was run. Typically the root level     of the project contents: String     The exact text to append into the file.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Juissie-GW/Juissie.jl/blob/15e686ea43ed50150619b8fe99cf4f4d60cabbe5/src/SemanticSearch/DataReader/TxtReader.jl#L85-L103">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Juissie.Generation.SemanticSearch.Backend.TxtReader.getAllTextInFile-Tuple{String}" href="#Juissie.Generation.SemanticSearch.Backend.TxtReader.getAllTextInFile-Tuple{String}"><code>Juissie.Generation.SemanticSearch.Backend.TxtReader.getAllTextInFile</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Open the provided filename, load all the data into memory, and return. This function will also manage the file socket open(...) close(...) properly. If there was an error in opening or reading the file then the empty  string will be returned</p><p><strong>Parameters</strong></p><p>filename: String     The name of the file to open. Relative file paths are evaluated from     the directory where the <code>julia</code> command was run. Typically the root level     of the project</p><p>Returns: String     The entire contets of the file, or an empty string if there was an issue</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Juissie-GW/Juissie.jl/blob/15e686ea43ed50150619b8fe99cf4f4d60cabbe5/src/SemanticSearch/DataReader/TxtReader.jl#L55-L70">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Juissie.Generation.SemanticSearch.Backend.TxtReader.splitFileIntoParts-Tuple{String, String, Int64}" href="#Juissie.Generation.SemanticSearch.Backend.TxtReader.splitFileIntoParts-Tuple{String, String, Int64}"><code>Juissie.Generation.SemanticSearch.Backend.TxtReader.splitFileIntoParts</code></a> — <span class="docstring-category">Method</span></header><section><div><p>A simple script that allows a user to split a large file into multiple smaller files.  This will create splits # of children files, each with a file size ~1/splits  of the origional target file.</p><p><strong>Parameters</strong></p><p>fileToSplit : String     The name of the file to read and split into multiple parts.     If an absolute file path is given then that will be     used. Otherwise, relative file paths are evaluated from the location that     the <code>julia</code> command was run from (typically the root level of this project) outputFileNameBase : String     The template for the name of the children split-out files.      Each split out file with have the format of &lt;outputFileNameBase&gt;_&lt;#&gt;      where # starts at 1 and increments by 1 for each subsequent file.      There will be <code>splits</code> number of children files splits : Int     How many children files should be created?</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Juissie-GW/Juissie.jl/blob/15e686ea43ed50150619b8fe99cf4f4d60cabbe5/src/SemanticSearch/DataReader/TxtReader.jl#L6-L25">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Juissie.SemanticSearch.Embedding.embed-Tuple{Embedder, String}" href="#Juissie.SemanticSearch.Embedding.embed-Tuple{Embedder, String}"><code>Juissie.SemanticSearch.Embedding.embed</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function embed(embedder::Embedder, text::String)::AbstractVector</code></pre><p>Embeds a textual sequence using a provided model</p><p><strong>Parameters</strong></p><p>embedder : Embedder     an initialized Embedder struct text : String     the text sequence you want to embed</p><p><strong>Notes</strong></p><p>This is sort of like a class method for the Embedder</p><p>Julia has something called multiple dispatch that can be used to  make this cleaner, but I&#39;m going to handle that at a later times</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Juissie-GW/Juissie.jl/blob/15e686ea43ed50150619b8fe99cf4f4d60cabbe5/src/SemanticSearch/Embedding.jl#L53-L71">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Juissie.SemanticSearch.Embedding.embed_from_bert-Tuple{Embedder, String}" href="#Juissie.SemanticSearch.Embedding.embed_from_bert-Tuple{Embedder, String}"><code>Juissie.SemanticSearch.Embedding.embed_from_bert</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function embed_from_bert(embedder::Embedder, text::String)</code></pre><p>Embeds a textual sequence using a provided Bert model</p><p><strong>Parameters</strong></p><p>embedder : Embedder     an initialized Embedder struct     the associated model and tokenizer should be Bert-specific text : String     the text sequence you want to embed</p><p>return : cls_embedding     The results from passing the text through the encoder, throught the model,     and after stripping </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Juissie-GW/Juissie.jl/blob/15e686ea43ed50150619b8fe99cf4f4d60cabbe5/src/SemanticSearch/Embedding.jl#L85-L101">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Juissie.SemanticSearch.Embedding.Embedder" href="#Juissie.SemanticSearch.Embedding.Embedder"><code>Juissie.SemanticSearch.Embedding.Embedder</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Embedder</code></pre><p>A struct for holding a model and a tokenizer</p><p><strong>Attributes</strong></p><p>tokenizer : a tokenizer object, e.g. BertTextEncoder     maps your string to tokens the model can understand model : a model object, e.g. HGFBertModel     the actual model architecture and weights to perform inference with</p><p><strong>Notes</strong></p><p>You can get class-like behavior in Julia by defining a struct and functions that operate on that struct.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Juissie-GW/Juissie.jl/blob/15e686ea43ed50150619b8fe99cf4f4d60cabbe5/src/SemanticSearch/Embedding.jl#L12-L28">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Juissie.SemanticSearch.Embedding.Embedder-Tuple{String}" href="#Juissie.SemanticSearch.Embedding.Embedder-Tuple{String}"><code>Juissie.SemanticSearch.Embedding.Embedder</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function Embedder(model_name::String)</code></pre><p>Function to initialize an Embedder struct from a HuggingFace model path.</p><p><strong>Parameters</strong></p><p>model_name : String     a path to a HuggingFace-hosted model     e.g. &quot;BAAI/bge-small-en-v1.5&quot;</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Juissie-GW/Juissie.jl/blob/15e686ea43ed50150619b8fe99cf4f4d60cabbe5/src/SemanticSearch/Embedding.jl#L35-L46">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Juissie.SemanticSearch.TextUtils.chunkify" href="#Juissie.SemanticSearch.TextUtils.chunkify"><code>Juissie.SemanticSearch.TextUtils.chunkify</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">function chunkify(text::String, tokenizer, sequence_length::Int=512)</code></pre><p>Splits a provided text (e.g. paragraph) into chunks that are each as many sentences as possible while keeping the chunk&#39;s token lenght below the sequence_length. This ensures that each chunk can be fully encoded by the embedder.</p><p><strong>Parameters</strong></p><p>text : String     The text you want to split into chunks. tokenizer : a tokenizer object, e.g. BertTextEncoder     The tokenizer you will be using sequence_length : Int     The maximum number of tokens per chunk.     Ideally, should correspond to the max sequence length of the tokenizer</p><p><strong>Example Usage</strong></p><pre><code class="nohighlight hljs">&gt;&gt;&gt; chunkify(
    &#39;&#39;&#39;Hold me closer, tiny dancer. Count the headlights on the highway. Lay me down in sheets of linen. Peter Piper picked a peck of pickled peppers. A peck of pickled peppers Peter Piper picked.
    &#39;&#39;&#39;, 
    corpus.embedder.tokenizer, 
    20
)

4-element Vector{Any}:
&quot;Hold me closer, tiny dancer. Count the headlights on the highway.&quot;
&quot;Lay me down in sheets of linen.&quot;
&quot;Peter Piper picked a peck of pickled peppers.&quot;
&quot;A peck of pickled peppers Peter Piper picked.&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Juissie-GW/Juissie.jl/blob/15e686ea43ed50150619b8fe99cf4f4d60cabbe5/src/SemanticSearch/TextUtils.jl#L81-L112">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Juissie.SemanticSearch.TextUtils.get_files_path-Tuple{}" href="#Juissie.SemanticSearch.TextUtils.get_files_path-Tuple{}"><code>Juissie.SemanticSearch.TextUtils.get_files_path</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function get_files_path()</code></pre><p>Simple function to return the path to the files subdirectory.</p><p><strong>Example Usage</strong></p><p>test<em>bin</em>path = get<em>files</em>path()*&quot;test.bin&quot;</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Juissie-GW/Juissie.jl/blob/15e686ea43ed50150619b8fe99cf4f4d60cabbe5/src/SemanticSearch/TextUtils.jl#L13-L21">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Juissie.SemanticSearch.TextUtils.read_html_url" href="#Juissie.SemanticSearch.TextUtils.read_html_url"><code>Juissie.SemanticSearch.TextUtils.read_html_url</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">read_html_url(url::String, elements::Array{String})</code></pre><p>Returns a string of text from the provided HTML elements on a webpage.</p><p><strong>Parameters</strong></p><p>url : String     the url you want to read elements : Array{String}     html elements to look for in the web page, e.g. [&quot;h1&quot;, &quot;p&quot;].</p><p><strong>Notes</strong></p><p>Defaults to extracting headers and paragraphs</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Juissie-GW/Juissie.jl/blob/15e686ea43ed50150619b8fe99cf4f4d60cabbe5/src/SemanticSearch/TextUtils.jl#L27-L42">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Juissie.SemanticSearch.TextUtils.sentence_splitter-Tuple{String}" href="#Juissie.SemanticSearch.TextUtils.sentence_splitter-Tuple{String}"><code>Juissie.SemanticSearch.TextUtils.sentence_splitter</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function sentence_splitter(text::String)</code></pre><p>Uses basic regex to divide a provided text (e.g. paragraph) into sentences.</p><p><strong>Parameters</strong></p><p>text : String     The text you want to split into sentences.</p><p><strong>Notes</strong></p><p>Regex is hard to read. The first part looks for spaces following  end-of-sentence punctuation. The second part matches at the end of the string.</p><p>Regex in Julia uses an r identifier prefix.</p><p><strong>References</strong></p><p>https://www.geeksforgeeks.org/regular-expressions-in-julia/</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Juissie-GW/Juissie.jl/blob/15e686ea43ed50150619b8fe99cf4f4d60cabbe5/src/SemanticSearch/TextUtils.jl#L54-L74">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Juissie.Generation.SemanticSearch.Backend.PdfReader.bufferToString!-Tuple{IOBuffer}" href="#Juissie.Generation.SemanticSearch.Backend.PdfReader.bufferToString!-Tuple{IOBuffer}"><code>Juissie.Generation.SemanticSearch.Backend.PdfReader.bufferToString!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Extract the contents of the buffer and convert it into a string object</code></pre><p>WARNING: This function will clear out the contents of the buffer</p><p><strong>Parameters</strong></p><p>buff : The buffer to clear, it&#39;s contents will be returned as a string</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Juissie-GW/Juissie.jl/blob/15e686ea43ed50150619b8fe99cf4f4d60cabbe5/src/SemanticSearch/DataReader/PdfReader.jl#L150-L157">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Juissie.Generation.SemanticSearch.Backend.PdfReader.getAllTextInPDF" href="#Juissie.Generation.SemanticSearch.Backend.PdfReader.getAllTextInPDF"><code>Juissie.Generation.SemanticSearch.Backend.PdfReader.getAllTextInPDF</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Extract all the text data from the provided pdf file.</code></pre><p>Open the pdf at the provided file location, extract all the text data from it (as far as possible), and return that text data as a vector of strings. Each entry in the rsult vector is the appended sum of some number of pages in the PDF. 100 Pages per entry is default. For example, the getAllTextInPDF(...)[0] will be a  long string containing 100 pages worth of data. The next entry represents the next 100  pages, etc.</p><p>NOTE: This function is a &quot;best effort&quot; function, meaning that it will try to extract as many pages as it can. But if there are pages that are invalid, or otherwise can not be properly parsed then they will simply be ignored and not included in the  returned strings.</p><p><strong>Parameters</strong></p><p>fileLocation : The full path to the PDF file to open. This should be relative from where the <code>julia</code> command has been run (not relative to this source file)</p><p>pagesPerEntry : How many pages should be collected into the buffere before turning it into an entry in the result vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Juissie-GW/Juissie.jl/blob/15e686ea43ed50150619b8fe99cf4f4d60cabbe5/src/SemanticSearch/DataReader/PdfReader.jl#L9-L30">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Juissie.Generation.SemanticSearch.Backend.PdfReader.getPagesFromPdf-Tuple{PDFIO.PD.PDDocImpl, Number, Number}" href="#Juissie.Generation.SemanticSearch.Backend.PdfReader.getPagesFromPdf-Tuple{PDFIO.PD.PDDocImpl, Number, Number}"><code>Juissie.Generation.SemanticSearch.Backend.PdfReader.getPagesFromPdf</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Collect and return all the text data found in the pdf file found in the provided page range.</code></pre><p>Using the provided PDF Handel, loop over all the pages in the range and attempt to extract the text data. All the collected data will be returned.</p><p>The specific pages to read are defined by [firstPageInclusive, lastPageInclusive] which (naturally) defines an inclusive range. Meaning the first and last page number will be included in the returned string. These ranges SHOULD be valid (ie, in the range [1, MaxPageCount]) but error checking will coerce the values to a proper range.</p><p><strong>Parameters</strong></p><p>pdfHandel : The PDF file to extract data from firstPageInclusive : The first page in the range to read lastPageInclusive : The last page in the range to read</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Juissie-GW/Juissie.jl/blob/15e686ea43ed50150619b8fe99cf4f4d60cabbe5/src/SemanticSearch/DataReader/PdfReader.jl#L75-L92">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Juissie.Generation.SemanticSearch.Backend.PdfReader.getPagesFromPdf-Tuple{String, Number, Number}" href="#Juissie.Generation.SemanticSearch.Backend.PdfReader.getPagesFromPdf-Tuple{String, Number, Number}"><code>Juissie.Generation.SemanticSearch.Backend.PdfReader.getPagesFromPdf</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Collect and return all the text data found in the pdf file found in the provided page range.</code></pre><p>Using the provided file path, open the PDF and loop over all the pages in the range and attempt to extract the text data. All the collected data will be returned.</p><p>The specific pages to read are defined by [firstPageInclusive, lastPageInclusive] which (naturally) defines an inclusive range. Meaning the first and last page number will be included in the returned string. These ranges SHOULD be valid (ie, in the range [1, MaxPageCount]) but error checking will coerce the values to a proper range.</p><p><strong>Parameters</strong></p><p>fileLocation : The location of the PDF to read firstPageInclusive : The first page in the range to read lastPageInclusive : The last page in the range to read</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Juissie-GW/Juissie.jl/blob/15e686ea43ed50150619b8fe99cf4f4d60cabbe5/src/SemanticSearch/DataReader/PdfReader.jl#L47-L64">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Juissie.Generation.SemanticSearch.Backend.PdfReader.getPagesInPDF_All-Tuple{String}" href="#Juissie.Generation.SemanticSearch.Backend.PdfReader.getPagesInPDF_All-Tuple{String}"><code>Juissie.Generation.SemanticSearch.Backend.PdfReader.getPagesInPDF_All</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Extract all the text data from the provided pdf file.</code></pre><p>Open the pdf at the provided file location, extract all the text data from it (as far as possible), and return that text data as a vector of strings. Each entry in the result vector is the data from a single page of the PDF file.</p><p>NOTE: This function is a &quot;best effort&quot; function, meaning that it will try to extract as many pages as it can. But if there are pages that are invalid, or otherwise can not be properly parsed then they will simply be ignored and not included in the  returned strings.</p><p><strong>Parameters</strong></p><p>fileLocation : The full path to the PDF file to open. This should be relative from where the <code>julia</code> command has been run (not relative to this source file)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Juissie-GW/Juissie.jl/blob/15e686ea43ed50150619b8fe99cf4f4d60cabbe5/src/SemanticSearch/DataReader/PdfReader.jl#L130-L145">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Juissie.SemanticSearch.Backend.Embedding.embed-Tuple{Juissie.SemanticSearch.Backend.Embedding.Embedder, String}" href="#Juissie.SemanticSearch.Backend.Embedding.embed-Tuple{Juissie.SemanticSearch.Backend.Embedding.Embedder, String}"><code>Juissie.SemanticSearch.Backend.Embedding.embed</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function embed(embedder::Embedder, text::String)::AbstractVector</code></pre><p>Embeds a textual sequence using a provided model</p><p><strong>Parameters</strong></p><p>embedder : Embedder     an initialized Embedder struct text : String     the text sequence you want to embed</p><p><strong>Notes</strong></p><p>This is sort of like a class method for the Embedder</p><p>Julia has something called multiple dispatch that can be used to  make this cleaner, but I&#39;m going to handle that at a later times</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Juissie-GW/Juissie.jl/blob/15e686ea43ed50150619b8fe99cf4f4d60cabbe5/src/SemanticSearch/Embedding.jl#L53-L71">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Juissie.SemanticSearch.Backend.Embedding.embed_from_bert-Tuple{Juissie.SemanticSearch.Backend.Embedding.Embedder, String}" href="#Juissie.SemanticSearch.Backend.Embedding.embed_from_bert-Tuple{Juissie.SemanticSearch.Backend.Embedding.Embedder, String}"><code>Juissie.SemanticSearch.Backend.Embedding.embed_from_bert</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function embed_from_bert(embedder::Embedder, text::String)</code></pre><p>Embeds a textual sequence using a provided Bert model</p><p><strong>Parameters</strong></p><p>embedder : Embedder     an initialized Embedder struct     the associated model and tokenizer should be Bert-specific text : String     the text sequence you want to embed</p><p>return : cls_embedding     The results from passing the text through the encoder, throught the model,     and after stripping </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Juissie-GW/Juissie.jl/blob/15e686ea43ed50150619b8fe99cf4f4d60cabbe5/src/SemanticSearch/Embedding.jl#L85-L101">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Juissie.SemanticSearch.Backend.Embedding.Embedder" href="#Juissie.SemanticSearch.Backend.Embedding.Embedder"><code>Juissie.SemanticSearch.Backend.Embedding.Embedder</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Embedder</code></pre><p>A struct for holding a model and a tokenizer</p><p><strong>Attributes</strong></p><p>tokenizer : a tokenizer object, e.g. BertTextEncoder     maps your string to tokens the model can understand model : a model object, e.g. HGFBertModel     the actual model architecture and weights to perform inference with</p><p><strong>Notes</strong></p><p>You can get class-like behavior in Julia by defining a struct and functions that operate on that struct.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Juissie-GW/Juissie.jl/blob/15e686ea43ed50150619b8fe99cf4f4d60cabbe5/src/SemanticSearch/Embedding.jl#L12-L28">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Juissie.SemanticSearch.Backend.Embedding.Embedder-Tuple{String}" href="#Juissie.SemanticSearch.Backend.Embedding.Embedder-Tuple{String}"><code>Juissie.SemanticSearch.Backend.Embedding.Embedder</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function Embedder(model_name::String)</code></pre><p>Function to initialize an Embedder struct from a HuggingFace model path.</p><p><strong>Parameters</strong></p><p>model_name : String     a path to a HuggingFace-hosted model     e.g. &quot;BAAI/bge-small-en-v1.5&quot;</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Juissie-GW/Juissie.jl/blob/15e686ea43ed50150619b8fe99cf4f4d60cabbe5/src/SemanticSearch/Embedding.jl#L35-L46">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Juissie.SemanticSearch.Backend.TextUtils.chunkify" href="#Juissie.SemanticSearch.Backend.TextUtils.chunkify"><code>Juissie.SemanticSearch.Backend.TextUtils.chunkify</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">function chunkify(text::String, tokenizer, sequence_length::Int=512)</code></pre><p>Splits a provided text (e.g. paragraph) into chunks that are each as many sentences as possible while keeping the chunk&#39;s token lenght below the sequence_length. This ensures that each chunk can be fully encoded by the embedder.</p><p><strong>Parameters</strong></p><p>text : String     The text you want to split into chunks. tokenizer : a tokenizer object, e.g. BertTextEncoder     The tokenizer you will be using sequence_length : Int     The maximum number of tokens per chunk.     Ideally, should correspond to the max sequence length of the tokenizer</p><p><strong>Example Usage</strong></p><pre><code class="nohighlight hljs">&gt;&gt;&gt; chunkify(
    &#39;&#39;&#39;Hold me closer, tiny dancer. Count the headlights on the highway. Lay me down in sheets of linen. Peter Piper picked a peck of pickled peppers. A peck of pickled peppers Peter Piper picked.
    &#39;&#39;&#39;, 
    corpus.embedder.tokenizer, 
    20
)

4-element Vector{Any}:
&quot;Hold me closer, tiny dancer. Count the headlights on the highway.&quot;
&quot;Lay me down in sheets of linen.&quot;
&quot;Peter Piper picked a peck of pickled peppers.&quot;
&quot;A peck of pickled peppers Peter Piper picked.&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Juissie-GW/Juissie.jl/blob/15e686ea43ed50150619b8fe99cf4f4d60cabbe5/src/SemanticSearch/TextUtils.jl#L81-L112">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Juissie.SemanticSearch.Backend.TextUtils.get_files_path-Tuple{}" href="#Juissie.SemanticSearch.Backend.TextUtils.get_files_path-Tuple{}"><code>Juissie.SemanticSearch.Backend.TextUtils.get_files_path</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function get_files_path()</code></pre><p>Simple function to return the path to the files subdirectory.</p><p><strong>Example Usage</strong></p><p>test<em>bin</em>path = get<em>files</em>path()*&quot;test.bin&quot;</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Juissie-GW/Juissie.jl/blob/15e686ea43ed50150619b8fe99cf4f4d60cabbe5/src/SemanticSearch/TextUtils.jl#L13-L21">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Juissie.SemanticSearch.Backend.TextUtils.read_html_url" href="#Juissie.SemanticSearch.Backend.TextUtils.read_html_url"><code>Juissie.SemanticSearch.Backend.TextUtils.read_html_url</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">read_html_url(url::String, elements::Array{String})</code></pre><p>Returns a string of text from the provided HTML elements on a webpage.</p><p><strong>Parameters</strong></p><p>url : String     the url you want to read elements : Array{String}     html elements to look for in the web page, e.g. [&quot;h1&quot;, &quot;p&quot;].</p><p><strong>Notes</strong></p><p>Defaults to extracting headers and paragraphs</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Juissie-GW/Juissie.jl/blob/15e686ea43ed50150619b8fe99cf4f4d60cabbe5/src/SemanticSearch/TextUtils.jl#L27-L42">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Juissie.SemanticSearch.Backend.TextUtils.sentence_splitter-Tuple{String}" href="#Juissie.SemanticSearch.Backend.TextUtils.sentence_splitter-Tuple{String}"><code>Juissie.SemanticSearch.Backend.TextUtils.sentence_splitter</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function sentence_splitter(text::String)</code></pre><p>Uses basic regex to divide a provided text (e.g. paragraph) into sentences.</p><p><strong>Parameters</strong></p><p>text : String     The text you want to split into sentences.</p><p><strong>Notes</strong></p><p>Regex is hard to read. The first part looks for spaces following  end-of-sentence punctuation. The second part matches at the end of the string.</p><p>Regex in Julia uses an r identifier prefix.</p><p><strong>References</strong></p><p>https://www.geeksforgeeks.org/regular-expressions-in-julia/</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Juissie-GW/Juissie.jl/blob/15e686ea43ed50150619b8fe99cf4f4d60cabbe5/src/SemanticSearch/TextUtils.jl#L54-L74">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Juissie.Generation.SemanticSearch.Backend.Embedding.embed-Tuple{Juissie.Generation.SemanticSearch.Backend.Embedding.Embedder, String}" href="#Juissie.Generation.SemanticSearch.Backend.Embedding.embed-Tuple{Juissie.Generation.SemanticSearch.Backend.Embedding.Embedder, String}"><code>Juissie.Generation.SemanticSearch.Backend.Embedding.embed</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function embed(embedder::Embedder, text::String)::AbstractVector</code></pre><p>Embeds a textual sequence using a provided model</p><p><strong>Parameters</strong></p><p>embedder : Embedder     an initialized Embedder struct text : String     the text sequence you want to embed</p><p><strong>Notes</strong></p><p>This is sort of like a class method for the Embedder</p><p>Julia has something called multiple dispatch that can be used to  make this cleaner, but I&#39;m going to handle that at a later times</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Juissie-GW/Juissie.jl/blob/15e686ea43ed50150619b8fe99cf4f4d60cabbe5/src/SemanticSearch/Embedding.jl#L53-L71">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Juissie.Generation.SemanticSearch.Backend.Embedding.embed_from_bert-Tuple{Juissie.Generation.SemanticSearch.Backend.Embedding.Embedder, String}" href="#Juissie.Generation.SemanticSearch.Backend.Embedding.embed_from_bert-Tuple{Juissie.Generation.SemanticSearch.Backend.Embedding.Embedder, String}"><code>Juissie.Generation.SemanticSearch.Backend.Embedding.embed_from_bert</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function embed_from_bert(embedder::Embedder, text::String)</code></pre><p>Embeds a textual sequence using a provided Bert model</p><p><strong>Parameters</strong></p><p>embedder : Embedder     an initialized Embedder struct     the associated model and tokenizer should be Bert-specific text : String     the text sequence you want to embed</p><p>return : cls_embedding     The results from passing the text through the encoder, throught the model,     and after stripping </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Juissie-GW/Juissie.jl/blob/15e686ea43ed50150619b8fe99cf4f4d60cabbe5/src/SemanticSearch/Embedding.jl#L85-L101">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Juissie.Generation.SemanticSearch.Backend.Embedding.Embedder" href="#Juissie.Generation.SemanticSearch.Backend.Embedding.Embedder"><code>Juissie.Generation.SemanticSearch.Backend.Embedding.Embedder</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Embedder</code></pre><p>A struct for holding a model and a tokenizer</p><p><strong>Attributes</strong></p><p>tokenizer : a tokenizer object, e.g. BertTextEncoder     maps your string to tokens the model can understand model : a model object, e.g. HGFBertModel     the actual model architecture and weights to perform inference with</p><p><strong>Notes</strong></p><p>You can get class-like behavior in Julia by defining a struct and functions that operate on that struct.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Juissie-GW/Juissie.jl/blob/15e686ea43ed50150619b8fe99cf4f4d60cabbe5/src/SemanticSearch/Embedding.jl#L12-L28">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Juissie.Generation.SemanticSearch.Backend.Embedding.Embedder-Tuple{String}" href="#Juissie.Generation.SemanticSearch.Backend.Embedding.Embedder-Tuple{String}"><code>Juissie.Generation.SemanticSearch.Backend.Embedding.Embedder</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function Embedder(model_name::String)</code></pre><p>Function to initialize an Embedder struct from a HuggingFace model path.</p><p><strong>Parameters</strong></p><p>model_name : String     a path to a HuggingFace-hosted model     e.g. &quot;BAAI/bge-small-en-v1.5&quot;</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Juissie-GW/Juissie.jl/blob/15e686ea43ed50150619b8fe99cf4f4d60cabbe5/src/SemanticSearch/Embedding.jl#L35-L46">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Juissie.Generation.SemanticSearch.TextUtils.chunkify" href="#Juissie.Generation.SemanticSearch.TextUtils.chunkify"><code>Juissie.Generation.SemanticSearch.TextUtils.chunkify</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">function chunkify(text::String, tokenizer, sequence_length::Int=512)</code></pre><p>Splits a provided text (e.g. paragraph) into chunks that are each as many sentences as possible while keeping the chunk&#39;s token lenght below the sequence_length. This ensures that each chunk can be fully encoded by the embedder.</p><p><strong>Parameters</strong></p><p>text : String     The text you want to split into chunks. tokenizer : a tokenizer object, e.g. BertTextEncoder     The tokenizer you will be using sequence_length : Int     The maximum number of tokens per chunk.     Ideally, should correspond to the max sequence length of the tokenizer</p><p><strong>Example Usage</strong></p><pre><code class="nohighlight hljs">&gt;&gt;&gt; chunkify(
    &#39;&#39;&#39;Hold me closer, tiny dancer. Count the headlights on the highway. Lay me down in sheets of linen. Peter Piper picked a peck of pickled peppers. A peck of pickled peppers Peter Piper picked.
    &#39;&#39;&#39;, 
    corpus.embedder.tokenizer, 
    20
)

4-element Vector{Any}:
&quot;Hold me closer, tiny dancer. Count the headlights on the highway.&quot;
&quot;Lay me down in sheets of linen.&quot;
&quot;Peter Piper picked a peck of pickled peppers.&quot;
&quot;A peck of pickled peppers Peter Piper picked.&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Juissie-GW/Juissie.jl/blob/15e686ea43ed50150619b8fe99cf4f4d60cabbe5/src/SemanticSearch/TextUtils.jl#L81-L112">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Juissie.Generation.SemanticSearch.TextUtils.get_files_path-Tuple{}" href="#Juissie.Generation.SemanticSearch.TextUtils.get_files_path-Tuple{}"><code>Juissie.Generation.SemanticSearch.TextUtils.get_files_path</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function get_files_path()</code></pre><p>Simple function to return the path to the files subdirectory.</p><p><strong>Example Usage</strong></p><p>test<em>bin</em>path = get<em>files</em>path()*&quot;test.bin&quot;</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Juissie-GW/Juissie.jl/blob/15e686ea43ed50150619b8fe99cf4f4d60cabbe5/src/SemanticSearch/TextUtils.jl#L13-L21">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Juissie.Generation.SemanticSearch.TextUtils.read_html_url" href="#Juissie.Generation.SemanticSearch.TextUtils.read_html_url"><code>Juissie.Generation.SemanticSearch.TextUtils.read_html_url</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">read_html_url(url::String, elements::Array{String})</code></pre><p>Returns a string of text from the provided HTML elements on a webpage.</p><p><strong>Parameters</strong></p><p>url : String     the url you want to read elements : Array{String}     html elements to look for in the web page, e.g. [&quot;h1&quot;, &quot;p&quot;].</p><p><strong>Notes</strong></p><p>Defaults to extracting headers and paragraphs</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Juissie-GW/Juissie.jl/blob/15e686ea43ed50150619b8fe99cf4f4d60cabbe5/src/SemanticSearch/TextUtils.jl#L27-L42">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Juissie.Generation.SemanticSearch.TextUtils.sentence_splitter-Tuple{String}" href="#Juissie.Generation.SemanticSearch.TextUtils.sentence_splitter-Tuple{String}"><code>Juissie.Generation.SemanticSearch.TextUtils.sentence_splitter</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function sentence_splitter(text::String)</code></pre><p>Uses basic regex to divide a provided text (e.g. paragraph) into sentences.</p><p><strong>Parameters</strong></p><p>text : String     The text you want to split into sentences.</p><p><strong>Notes</strong></p><p>Regex is hard to read. The first part looks for spaces following  end-of-sentence punctuation. The second part matches at the end of the string.</p><p>Regex in Julia uses an r identifier prefix.</p><p><strong>References</strong></p><p>https://www.geeksforgeeks.org/regular-expressions-in-julia/</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Juissie-GW/Juissie.jl/blob/15e686ea43ed50150619b8fe99cf4f4d60cabbe5/src/SemanticSearch/TextUtils.jl#L54-L74">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Generation.SemanticSearch.Backend.index-Tuple{Generation.SemanticSearch.Backend.Corpus}" href="#Generation.SemanticSearch.Backend.index-Tuple{Generation.SemanticSearch.Backend.Corpus}"><code>Generation.SemanticSearch.Backend.index</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function index(corpus::Corpus)</code></pre><p>Constructs the HNSW vector index from the data available. If the corpus has a corpus_name, then we also save the new index to disk. Must be run before searching.</p><p><strong>Parameters</strong></p><p>corpus : an initialized Corpus object     the corpus / &quot;vector database&quot; you want to use</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Juissie-GW/Juissie.jl/blob/34156a4b45050aa4c03cf687cbb0d750b1bb1789/src/SemanticSearch/Backend.jl#L398-L409">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Generation.SemanticSearch.Backend.load_corpus-Tuple{String}" href="#Generation.SemanticSearch.Backend.load_corpus-Tuple{String}"><code>Generation.SemanticSearch.Backend.load_corpus</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function load_corpus(corpus_name)</code></pre><p>Loads an already-initialized corpus from its associated &quot;artifacts&quot; (relational database, vector index, and informational json).</p><p><strong>Parameters</strong></p><p>corpus_name : str     the name of your EXISTING vector database</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Juissie-GW/Juissie.jl/blob/34156a4b45050aa4c03cf687cbb0d750b1bb1789/src/SemanticSearch/Backend.jl#L163-L173">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Generation.SemanticSearch.Backend.search" href="#Generation.SemanticSearch.Backend.search"><code>Generation.SemanticSearch.Backend.search</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">function search(corpus::Corpus, query::String, k::Int=5)</code></pre><p>Performs approximate nearest neighbor search to find the items in the vector index closest to the query.</p><p><strong>Parameters</strong></p><p>corpus : an initialized Corpus object     the corpus / &quot;vector database&quot; you want to use query : str     The text you want to search, e.g. your question     We embed this and perform semantic retrieval against the vector db k : int     The number of nearest-neighbor vectors to fetch</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Juissie-GW/Juissie.jl/blob/34156a4b45050aa4c03cf687cbb0d750b1bb1789/src/SemanticSearch/Backend.jl#L432-L447">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Generation.SemanticSearch.Backend.upsert_chunk-Tuple{Generation.SemanticSearch.Backend.Corpus, String, String}" href="#Generation.SemanticSearch.Backend.upsert_chunk-Tuple{Generation.SemanticSearch.Backend.Corpus, String, String}"><code>Generation.SemanticSearch.Backend.upsert_chunk</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function upsert_chunk(corpus::Corpus, chunk::String, doc_name::String)</code></pre><p>Given a new chunk of text, get embedding and insert into our vector DB. Not actually a full upsert, because we have to reindex later. Process:</p><ol><li>Generate an embedding for the text</li><li>Insert metadata into database</li><li>Increment idx counter</li></ol><p><strong>Parameters</strong></p><p>corpus : an initialized Corpus object     the corpus / &quot;vector database&quot; you want to use chunk : str     This is the text content of the chunk you want to upsert doc<em>name : str     The name of the document that chunk is from. For instance, if you      were upserting all the chunks in an academic paper, doc</em>name might     be the name of that paper</p><p><strong>Notes</strong></p><p>If the vectors have been indexed, this de-indexes them (i.e., they need to be indexed again). Currently, we handle this by setting hnsw to  nothing so that it gets caught later in search.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Juissie-GW/Juissie.jl/blob/34156a4b45050aa4c03cf687cbb0d750b1bb1789/src/SemanticSearch/Backend.jl#L239-L265">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Generation.SemanticSearch.Backend.upsert_document-Tuple{Generation.SemanticSearch.Backend.Corpus, String, String}" href="#Generation.SemanticSearch.Backend.upsert_document-Tuple{Generation.SemanticSearch.Backend.Corpus, String, String}"><code>Generation.SemanticSearch.Backend.upsert_document</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function upsert_document(corpus::Corpus, doc_text::String, doc_name::String)</code></pre><p>Upsert a whole document (i.e., long string). Does so by splitting the document into appropriately-sized chunks so no chunk exceeds the embedder&#39;s tokenization max sequence length, while prioritizing sentence endings.</p><p><strong>Parameters</strong></p><p>corpus : an initialized Corpus object     the corpus / &quot;vector database&quot; you want to use doc<em>text : str     A long string you want to upsert. We will break this into chunks and     upsert each chunk. doc</em>name : str     The name of the document the content is from</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Juissie-GW/Juissie.jl/blob/34156a4b45050aa4c03cf687cbb0d750b1bb1789/src/SemanticSearch/Backend.jl#L287-L303">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Generation.SemanticSearch.Backend.upsert_document-Tuple{Generation.SemanticSearch.Backend.Corpus, Vector{String}, String}" href="#Generation.SemanticSearch.Backend.upsert_document-Tuple{Generation.SemanticSearch.Backend.Corpus, Vector{String}, String}"><code>Generation.SemanticSearch.Backend.upsert_document</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function upsert_document(corpus::Corpus, documents::Vector{String}, doc_name::String)</code></pre><p>Upsert a collection of documents (i.e., a vector of long strings). Does so by upserting each entry of the provided documents vector (which in turn will chunkify, each document further into appropriately sized chunks).</p><p>See the upsert_document(...) above for more details</p><p><strong>Parameters</strong></p><p>corpus : an initialized Corpus object     the corpus / &quot;vector database&quot; you want to use documents : Vector{String}     a collection of long strings to upsert. doc_name : str     The name of the document the content is from</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Juissie-GW/Juissie.jl/blob/34156a4b45050aa4c03cf687cbb0d750b1bb1789/src/SemanticSearch/Backend.jl#L311-L328">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Generation.SemanticSearch.Backend.upsert_document_from_pdf-Tuple{Generation.SemanticSearch.Backend.Corpus, String, String}" href="#Generation.SemanticSearch.Backend.upsert_document_from_pdf-Tuple{Generation.SemanticSearch.Backend.Corpus, String, String}"><code>Generation.SemanticSearch.Backend.upsert_document_from_pdf</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function upsert_document_from_pdf(corpus::Corpus, filePath::String, doc_name::String)</code></pre><p>Upsert all the data in a PDF file into the provided corpus. See the upsert_document(...) above for more details.</p><p><strong>Parameters</strong></p><p>corpus : an initialized Corpus object     the corpus / &quot;vector database&quot; you want to use filePath : String     The path to the PDF file to read doc_name : str     The name of the document the content is from</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Juissie-GW/Juissie.jl/blob/34156a4b45050aa4c03cf687cbb0d750b1bb1789/src/SemanticSearch/Backend.jl#L361-L375">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Generation.SemanticSearch.Backend.upsert_document_from_txt-Tuple{Generation.SemanticSearch.Backend.Corpus, String, String}" href="#Generation.SemanticSearch.Backend.upsert_document_from_txt-Tuple{Generation.SemanticSearch.Backend.Corpus, String, String}"><code>Generation.SemanticSearch.Backend.upsert_document_from_txt</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function upsert_document_from_txt(corpus::Corpus, filePath::String, doc_name::String)</code></pre><p>Upsert all the data from the text file into the provided corpus.</p><p><strong>Parameters</strong></p><p>corpus : an initialized Corpus object     the corpus / &quot;vector database&quot; you want to use filePath : String     The path to the txt file to read doc_name : str     The name of the document the content is from</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Juissie-GW/Juissie.jl/blob/34156a4b45050aa4c03cf687cbb0d750b1bb1789/src/SemanticSearch/Backend.jl#L380-L393">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Generation.SemanticSearch.Backend.upsert_document_from_url" href="#Generation.SemanticSearch.Backend.upsert_document_from_url"><code>Generation.SemanticSearch.Backend.upsert_document_from_url</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">function upsert_document_from_url(corpus::Corpus, url::String, doc_name::String, elements::Array{String}=[&quot;h1&quot;, &quot;h2&quot;, &quot;p&quot;])</code></pre><p>Extracts element-tagged text from HTML and upserts as a document.</p><p><strong>Parameters</strong></p><p>corpus : an initialized Corpus object     the corpus / &quot;vector database&quot; you want to use url : String     The url you want to scrape for text doc_name : str     The name of the document the content is from elements : Array{String}     A list of HTML elements you want to pull the text from</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Juissie-GW/Juissie.jl/blob/34156a4b45050aa4c03cf687cbb0d750b1bb1789/src/SemanticSearch/Backend.jl#L335-L350">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Generation.SemanticSearch.Backend.Corpus" href="#Generation.SemanticSearch.Backend.Corpus"><code>Generation.SemanticSearch.Backend.Corpus</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Corpus</code></pre><p>Basically a vector database. It will have these attributes:</p><ol><li>a relational database (SQLite)</li><li>a vector index (HNSW)</li><li>an embedder (via Embedding.jl)</li></ol><p><strong>Attributes</strong></p><p>corpus<em>name : String or Nothing     this is the name of your corpus and will be used to access saved          corpuses     if Nothing, we can&#39;t save/load and everything will be in-memory db : a SQLite.DB connection object     this is a real relational database to store metadata (e.g. chunk text, doc name) hnsw : Hierarchical Navigable Small World object     this is our searchable vector index embedder : Embedder     an initialized Embedder struct max</em>seq<em>len : int     The maximum number of tokens per chunk.     This should be the max sequence length of the tokenizer data : Vector{Any}     The embeddings get stored here before we create the vector index next</em>idx : int     stores the index we&#39;ll use for the next-upserted chunk</p><p><strong>Notes</strong></p><p>The struct is mutable because we want to be able to change things like incrementing next_idx.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Juissie-GW/Juissie.jl/blob/34156a4b45050aa4c03cf687cbb0d750b1bb1789/src/SemanticSearch/Backend.jl#L32-L64">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Generation.SemanticSearch.Backend.Corpus" href="#Generation.SemanticSearch.Backend.Corpus"><code>Generation.SemanticSearch.Backend.Corpus</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">function Corpus(corpus_name::String, embedder_model_path::String=&quot;BAAI/bge-small-en-v1.5&quot;)</code></pre><p>Initializes a Corpus struct.</p><p>In particular, does the following:</p><ol><li>Initializes an embedder object</li><li>Creates a SQLite databse with the corpus name. It should have:</li></ol><ul><li>row-wise primary key uuid</li><li>doc_name representing the <em>parent</em> document</li><li>chunk text </li></ul><p>We can add more metadata later, if desired</p><p><strong>Parameters</strong></p><p>corpus<em>name : str or nothing     the name that you want to give the database     optional. if left as nothing, we use an in-memory database embedder</em>model<em>path : str     a path to a HuggingFace-hosted model     e.g. &quot;BAAI/bge-small-en-v1.5&quot; max</em>seq_len : int     The maximum number of tokens per chunk.     This should be the max sequence length of the tokenizer</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Juissie-GW/Juissie.jl/blob/34156a4b45050aa4c03cf687cbb0d750b1bb1789/src/SemanticSearch/Backend.jl#L75-L99">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Generation.build_full_query" href="#Generation.build_full_query"><code>Generation.build_full_query</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">function build_full_query(query::String, context::OptionalContext=nothing)</code></pre><p>Given a query and a list of contextual chunks, construct a full query incorporating both.</p><p><strong>Parameters</strong></p><p>query : String     the main instruction or query string context : OptionalContext, which is Union{Vector{String}, Nothing}     optional list of chunks providing additional context for the query</p><p><strong>Notes</strong></p><p>We base our prompt off the Alpaca prompt, found here: https://github.com/tatsu-lab/stanford_alpaca with minor modifications that reflect our response preferences.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Juissie-GW/Juissie.jl/blob/34156a4b45050aa4c03cf687cbb0d750b1bb1789/src/Generation.jl#L398-L415">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Generation.check_oai_key_format-Tuple{String}" href="#Generation.check_oai_key_format-Tuple{String}"><code>Generation.check_oai_key_format</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function check_oai_key_format(key::String)</code></pre><p>Uses regex to check if a provided string is in the expected format of an OpenAI     API Key</p><p><strong>Parameters</strong></p><p>key : String     the key you want to check</p><p><strong>Notes</strong></p><p>See here for more on the regex:</p><ul><li>https://en.wikibooks.org/wiki/Introducing<em>Julia/Strings</em>and<em>characters#Finding</em>and<em>replacing</em>things<em>inside</em>strings</li></ul><p>Uses format rule provided here:</p><ul><li>https://github.com/secretlint/secretlint/issues/676</li><li>https://community.openai.com/t/what-are-the-valid-characters-for-the-apikey/288643</li></ul><p>Note that this only checks the key format, not whether the key is valid or has not  been revoked.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Juissie-GW/Juissie.jl/blob/34156a4b45050aa4c03cf687cbb0d750b1bb1789/src/Generation.jl#L33-L55">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Generation.generate" href="#Generation.generate"><code>Generation.generate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">generate(generator::Union{OAIGenerator, Nothing}, query::String, context::OptionalContext=nothing, temperature::Float64=0.7)</code></pre><p>Generate a response based on a given query and optional context using the specified OAIGenerator. This function constructs a full query, sends it to the OpenAI API, and returns the generated response.</p><p><strong>Parameters</strong></p><p>generator : Union{OAIGenerator, Nothing}     an initialized generator (e..g OAIGenerator)     leaving this as a union with nothing to note that we may want to support other      generator types in the future (e.g. HFGenerator, etc.) query : String     the main query string. This is basically your question context : OptionalContext, which is Union{Vector{String}, Nothing}     optional list of contextual chunk strings to provide the generator additional      context for the query. Ultimately, these will be coming from our vector DB temperature : Float64     controls the stochasticity of the output generated by the model</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Juissie-GW/Juissie.jl/blob/34156a4b45050aa4c03cf687cbb0d750b1bb1789/src/Generation.jl#L454-L472">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Generation.generate_with_corpus" href="#Generation.generate_with_corpus"><code>Generation.generate_with_corpus</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">function generate_with_corpus(generator::Union{OAIGenerator, Nothing}, corpus::Corpus, query::String, k::Int=5, temperature::Float64=0.7)</code></pre><p><strong>Parameters</strong></p><p>generator : Union{OAIGenerator, Nothing}     an initialized generator (e..g OAIGenerator)     leaving this as a union with nothing to note that we may want to support other      generator types in the future (e.g. HFGenerator, etc.) corpus : an initialized Corpus object     the corpus / &quot;vector database&quot; you want to use query : String     the main instruction or query string. This is basically your question k : int     The number of nearest-neighbor vectors to fetch from the corpus to build your context temperature : Float64     controls the stochasticity of the output generated by the model</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Juissie-GW/Juissie.jl/blob/34156a4b45050aa4c03cf687cbb0d750b1bb1789/src/Generation.jl#L523-L540">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Generation.load_OAIGeneratorWithCorpus" href="#Generation.load_OAIGeneratorWithCorpus"><code>Generation.load_OAIGeneratorWithCorpus</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">function load_OAIGeneratorWithCorpus(corpus_name::String, auth_token::Union{String, Nothing}=nothing)</code></pre><p>Loads an existing corpus and uses it to initialize an OAIGeneratorWithCorpus</p><p><strong>Parameters</strong></p><p>corpus<em>name : str     the name that you want to give the database auth</em>token :: Union{String, Nothing}     this is your OPENAI API key. You can either pass it explicitly as a string     or leave this argument as nothing. In the latter case, we will look in your     environmental variables for &quot;OAI_KEY&quot;</p><p><strong>Notes</strong></p><p>corpus<em>name is ordered first because Julia uses positional arguments and  auth</em>token is optional.</p><p>When instantiating a new OAIGenerator in an externally-viewable setting (e.g. notebooks committed to GitHub or a public demo), it is important to place a semicolon after the command, e.g.  &#39;&#39;&#39;generator=load<em>OAIGeneratorWithCorpus(&quot;greek</em>philosophers&quot;);&#39;&#39;&#39; to ensure that your OAI API key is not inadvertently shared.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Juissie-GW/Juissie.jl/blob/34156a4b45050aa4c03cf687cbb0d750b1bb1789/src/Generation.jl#L323-L347">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Generation.load_OllamaGeneratorWithCorpus" href="#Generation.load_OllamaGeneratorWithCorpus"><code>Generation.load_OllamaGeneratorWithCorpus</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">function load_OllamaGeneratorWithCorpus(corpus_name::String, model_name::String = &quot;mistral:7b-instruct&quot;)</code></pre><p>Loads an existing corpus and uses it to initialize an OllamaGeneratorWithCorpus</p><p><strong>Parameters</strong></p><p>corpus<em>name : str     the name that you want to give the database model</em>name :: String     this is an Ollama model tag. see https://ollama.com/library     defaults to mistral 7b instruct</p><p><strong>Notes</strong></p><p>corpus<em>name is ordered first because Julia uses positional arguments and  model</em>name is optional.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Juissie-GW/Juissie.jl/blob/34156a4b45050aa4c03cf687cbb0d750b1bb1789/src/Generation.jl#L364-L381">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Generation.upsert_chunk_to_generator-Tuple{GeneratorWithCorpus, String, String}" href="#Generation.upsert_chunk_to_generator-Tuple{GeneratorWithCorpus, String, String}"><code>Generation.upsert_chunk_to_generator</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function upsert_chunk_to_generator(generator::GeneratorWithCorpus, chunk::String, doc_name::String)</code></pre><p>Equivalent to Backend.upsert_chunk, but takes a GeneratorWithCorpus instead of a Corpus.</p><p><strong>Parameters</strong></p><p>generator : any struct that subtypes GeneratorWithCorpus     the generator (with corpus) you want to use chunk : str     This is the text content of the chunk you want to upsert doc<em>name : str     The name of the document that chunk is from. For instance, if you      were upserting all the chunks in an academic paper, doc</em>name might     be the name of that paper</p><p><strong>Notes</strong></p><p>One would expect Julia&#39;s multiple dispatch to allow us to call this upsert<em>chunk, but not so. The conflict arises in Juissie, where  we would have both SemanticSearch and Generation exporting  upsert</em>chunk. This means any uses of it in Juissie must be  qualified, and without doing so, neither actually gets defined.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Juissie-GW/Juissie.jl/blob/34156a4b45050aa4c03cf687cbb0d750b1bb1789/src/Generation.jl#L552-L576">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Generation.upsert_document_from_url_to_generator" href="#Generation.upsert_document_from_url_to_generator"><code>Generation.upsert_document_from_url_to_generator</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">function upsert_document_from_url_to_generator(generator::GeneratorWithCorpus, url::String, doc_name::String, elements::Array{String}=[&quot;h1&quot;, &quot;h2&quot;, &quot;p&quot;])</code></pre><p>Equivalent to Backend.upsert<em>document</em>from_url, but takes a  GeneratorWithCorpus instead of a Corpus.</p><p><strong>Parameters</strong></p><p>generator : any struct that subtypes GeneratorWithCorpus     the generator (with corpus) you want to use url : String     The url you want to scrape for text doc_name : str     The name of the document the content is from elements : Array{String}     A list of HTML elements you want to pull the text from</p><p><strong>Notes</strong></p><p>See note for upsert<em>chunk</em>to_generator - same idea.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Juissie-GW/Juissie.jl/blob/34156a4b45050aa4c03cf687cbb0d750b1bb1789/src/Generation.jl#L613-L633">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Generation.upsert_document_to_generator-Tuple{GeneratorWithCorpus, String, String}" href="#Generation.upsert_document_to_generator-Tuple{GeneratorWithCorpus, String, String}"><code>Generation.upsert_document_to_generator</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function upsert_document_to_generator(generator::GeneratorWithCorpus, doc_text::String, doc_name::String)</code></pre><p>Equivalent to Backend.upsert_document, but takes a GeneratorWithCorpus instead of a Corpus.</p><p><strong>Parameters</strong></p><p>generator : any struct that subtypes GeneratorWithCorpus     the generator (with corpus) you want to use doc<em>text : str     A long string you want to upsert. We will break this into chunks and     upsert each chunk. doc</em>name : str     The name of the document the content is from</p><p><strong>Notes</strong></p><p>See note for upsert<em>chunk</em>to_generator - same idea.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Juissie-GW/Juissie.jl/blob/34156a4b45050aa4c03cf687cbb0d750b1bb1789/src/Generation.jl#L585-L604">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Generation.OAIGenerator" href="#Generation.OAIGenerator"><code>Generation.OAIGenerator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">function OAIGenerator(auth_token::Union{String, Nothing})</code></pre><p>Initializes an OAIGenerator struct.</p><p><strong>Parameters</strong></p><p>auth<em>token :: Union{String, Nothing}     this is your OPENAI API key. You can either pass it explicitly as a string     or leave this argument as nothing. In the latter case, we will look in your     environmental variables for &quot;OAI</em>KEY&quot;</p><p><strong>Notes</strong></p><p>When instantiating a new OAIGenerator in an externally-viewable setting (e.g. notebooks committed to GitHub or a public demo), it is important to place a semicolon after the command, e.g.  &#39;&#39;&#39;generator=load<em>OAIGeneratorWithCorpus(&quot;greek</em>philosophers&quot;);&#39;&#39;&#39; to ensure that your OAI API key is not inadvertently shared.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Juissie-GW/Juissie.jl/blob/34156a4b45050aa4c03cf687cbb0d750b1bb1789/src/Generation.jl#L168-L187">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Generation.OAIGenerator" href="#Generation.OAIGenerator"><code>Generation.OAIGenerator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct OAIGenerator</code></pre><p>A struct for handling natural language generation via OpenAI&#39;s gpt-3.5-turbo completion endpoint.</p><p><strong>Attributes</strong></p><p>url : String     the URL of the OpenAI API endpoint header : Vector{Pair{String, String}}     key-value pairs representing the HTTP headers for the request body : Dict{String, Any}     this is the JSON payload to be sent in the body of the request</p><p><strong>Notes</strong></p><p>All natural language generation should be done via a &quot;Generator&quot; object of some kind for consistency.</p><p>When instantiating a new OAIGenerator in an externally-viewable setting (e.g. notebooks committed to GitHub or a public demo), it is important to place a semicolon after the command, e.g.  &#39;&#39;&#39;generator=load<em>OAIGeneratorWithCorpus(&quot;greek</em>philosophers&quot;);&#39;&#39;&#39; to ensure that your OAI API key is not inadvertently shared.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Juissie-GW/Juissie.jl/blob/34156a4b45050aa4c03cf687cbb0d750b1bb1789/src/Generation.jl#L61-L86">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Generation.OAIGeneratorWithCorpus" href="#Generation.OAIGeneratorWithCorpus"><code>Generation.OAIGeneratorWithCorpus</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">function OAIGeneratorWithCorpus(auth_token::Union{String, Nothing}=nothing, corpus::Corpus)</code></pre><p>Initializes an OAIGeneratorWithCorpus.</p><p><strong>Parameters</strong></p><p>corpus<em>name : str or nothing     the name that you want to give the database     optional. if left as nothing, we use an in-memory database auth</em>token :: Union{String, Nothing}     this is your OPENAI API key. You can either pass it explicitly as a string     or leave this argument as nothing. In the latter case, we will look in your     environmental variables for &quot;OAI<em>KEY&quot; embedder</em>model<em>path : str     a path to a HuggingFace-hosted model     e.g. &quot;BAAI/bge-small-en-v1.5&quot; max</em>seq_len : int     The maximum number of tokens per chunk.     This should be the max sequence length of the tokenizer</p><p><strong>Notes</strong></p><p>When instantiating a new OAIGenerator in an externally-viewable setting (e.g. notebooks committed to GitHub or a public demo), it is important to place a semicolon after the command, e.g.  &#39;&#39;&#39;generator=load<em>OAIGeneratorWithCorpus(&quot;greek</em>philosophers&quot;);&#39;&#39;&#39; to ensure that your OAI API key is not inadvertently shared.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Juissie-GW/Juissie.jl/blob/34156a4b45050aa4c03cf687cbb0d750b1bb1789/src/Generation.jl#L237-L265">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Generation.OAIGeneratorWithCorpus" href="#Generation.OAIGeneratorWithCorpus"><code>Generation.OAIGeneratorWithCorpus</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct OAIGeneratorWithCorpus</code></pre><p>Like OAIGenerator, but has a corpus attached.</p><p><strong>Attributes</strong></p><p>url : String     the URL of the OpenAI API endpoint header : Vector{Pair{String, String}}     key-value pairs representing the HTTP headers for the request body : Dict{String, Any}     this is the JSON payload to be sent in the body of the request corpus : an initialized Corpus object     the corpus / &quot;vector database&quot; you want to use</p><p><strong>Notes</strong></p><p>When instantiating a new OAIGenerator in an externally-viewable setting (e.g. notebooks committed to GitHub or a public demo), it is important to place a semicolon after the command, e.g.  &#39;&#39;&#39;generator=load<em>OAIGeneratorWithCorpus(&quot;greek</em>philosophers&quot;);&#39;&#39;&#39; to ensure that your OAI API key is not inadvertently shared.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Juissie-GW/Juissie.jl/blob/34156a4b45050aa4c03cf687cbb0d750b1bb1789/src/Generation.jl#L113-L136">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Generation.OllamaGenerator" href="#Generation.OllamaGenerator"><code>Generation.OllamaGenerator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">function OllamaGenerator(model_name::String = &quot;mistral:7b-instruct&quot;)</code></pre><p>Initializes an OllamaGenerator struct for local text generation.</p><p><strong>Parameters</strong></p><p>model_name :: String     this is an Ollama model tag. see https://ollama.com/library     defaults to mistral 7b instruct</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Juissie-GW/Juissie.jl/blob/34156a4b45050aa4c03cf687cbb0d750b1bb1789/src/Generation.jl#L206-L217">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Generation.OllamaGenerator" href="#Generation.OllamaGenerator"><code>Generation.OllamaGenerator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct OllamaGenerator</code></pre><p>A struct for handling natural language generation locally.</p><p><strong>Attributes</strong></p><p>url : String     the URL of the local Ollama API endpoint header : Dict{String,Any}     HTTP header for the request body : Dict{String, Any}     this is the JSON payload to be sent in the body of the request</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Juissie-GW/Juissie.jl/blob/34156a4b45050aa4c03cf687cbb0d750b1bb1789/src/Generation.jl#L93-L106">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Generation.OllamaGeneratorWithCorpus" href="#Generation.OllamaGeneratorWithCorpus"><code>Generation.OllamaGeneratorWithCorpus</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">function OllamaGeneratorWithCorpus(corpus_name::Union{String,Nothing} = nothing, model_name::String = &quot;mistral:7b-instruct&quot;, embedder_model_path::String = &quot;BAAI/bge-small-en-v1.5&quot;, max_seq_len::Int = 512)</code></pre><p>Initializes an OllamaGeneratorWithCorpus.</p><p><strong>Parameters</strong></p><p>corpus<em>name : str or nothing     the name that you want to give the database     optional. if left as nothing, we use an in-memory database model</em>name :: String     this is an Ollama model tag. see https://ollama.com/library     defaults to mistral 7b instruct embedder<em>model</em>path : str     a path to a HuggingFace-hosted model     e.g. &quot;BAAI/bge-small-en-v1.5&quot; max<em>seq</em>len : int     The maximum number of tokens per chunk.     This should be the max sequence length of the tokenizer</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Juissie-GW/Juissie.jl/blob/34156a4b45050aa4c03cf687cbb0d750b1bb1789/src/Generation.jl#L284-L304">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Generation.OllamaGeneratorWithCorpus" href="#Generation.OllamaGeneratorWithCorpus"><code>Generation.OllamaGeneratorWithCorpus</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct_OllamaGeneratorWithCorpus</code></pre><p>Like OllamaGenerator, but has a corpus attached.</p><p><strong>Attributes</strong></p><p>url : String     the URL of the local Ollama API endpoint header : Dict{String,Any}     HTTP header for the request body : Dict{String, Any}     this is the JSON payload to be sent in the body of the request corpus : an initialized Corpus object     the corpus / &quot;vector database&quot; you want to use</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Juissie-GW/Juissie.jl/blob/34156a4b45050aa4c03cf687cbb0d750b1bb1789/src/Generation.jl#L144-L159">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Generation.SemanticSearch.Backend.TextUtils.chunkify" href="#Generation.SemanticSearch.Backend.TextUtils.chunkify"><code>Generation.SemanticSearch.Backend.TextUtils.chunkify</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">function chunkify(text::String, tokenizer, sequence_length::Int=512)</code></pre><p>Splits a provided text (e.g. paragraph) into chunks that are each as many sentences as possible while keeping the chunk&#39;s token lenght below the sequence_length. This ensures that each chunk can be fully encoded by the embedder.</p><p><strong>Parameters</strong></p><p>text : String     The text you want to split into chunks. tokenizer : a tokenizer object, e.g. BertTextEncoder     The tokenizer you will be using sequence_length : Int     The maximum number of tokens per chunk.     Ideally, should correspond to the max sequence length of the tokenizer</p><p><strong>Example Usage</strong></p><pre><code class="nohighlight hljs">&gt;&gt;&gt; chunkify(
    &#39;&#39;&#39;Hold me closer, tiny dancer. Count the headlights on the highway. Lay me down in sheets of linen. Peter Piper picked a peck of pickled peppers. A peck of pickled peppers Peter Piper picked.
    &#39;&#39;&#39;, 
    corpus.embedder.tokenizer, 
    20
)

4-element Vector{Any}:
&quot;Hold me closer, tiny dancer. Count the headlights on the highway.&quot;
&quot;Lay me down in sheets of linen.&quot;
&quot;Peter Piper picked a peck of pickled peppers.&quot;
&quot;A peck of pickled peppers Peter Piper picked.&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Juissie-GW/Juissie.jl/blob/34156a4b45050aa4c03cf687cbb0d750b1bb1789/src/SemanticSearch/TextUtils.jl#L81-L112">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Generation.SemanticSearch.Backend.TextUtils.get_files_path-Tuple{}" href="#Generation.SemanticSearch.Backend.TextUtils.get_files_path-Tuple{}"><code>Generation.SemanticSearch.Backend.TextUtils.get_files_path</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function get_files_path()</code></pre><p>Simple function to return the path to the files subdirectory.</p><p><strong>Example Usage</strong></p><p>test<em>bin</em>path = get<em>files</em>path()*&quot;test.bin&quot;</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Juissie-GW/Juissie.jl/blob/34156a4b45050aa4c03cf687cbb0d750b1bb1789/src/SemanticSearch/TextUtils.jl#L13-L21">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Generation.SemanticSearch.Backend.TextUtils.read_html_url" href="#Generation.SemanticSearch.Backend.TextUtils.read_html_url"><code>Generation.SemanticSearch.Backend.TextUtils.read_html_url</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">read_html_url(url::String, elements::Array{String})</code></pre><p>Returns a string of text from the provided HTML elements on a webpage.</p><p><strong>Parameters</strong></p><p>url : String     the url you want to read elements : Array{String}     html elements to look for in the web page, e.g. [&quot;h1&quot;, &quot;p&quot;].</p><p><strong>Notes</strong></p><p>Defaults to extracting headers and paragraphs</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Juissie-GW/Juissie.jl/blob/34156a4b45050aa4c03cf687cbb0d750b1bb1789/src/SemanticSearch/TextUtils.jl#L27-L42">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Generation.SemanticSearch.Backend.TextUtils.sentence_splitter-Tuple{String}" href="#Generation.SemanticSearch.Backend.TextUtils.sentence_splitter-Tuple{String}"><code>Generation.SemanticSearch.Backend.TextUtils.sentence_splitter</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function sentence_splitter(text::String)</code></pre><p>Uses basic regex to divide a provided text (e.g. paragraph) into sentences.</p><p><strong>Parameters</strong></p><p>text : String     The text you want to split into sentences.</p><p><strong>Notes</strong></p><p>Regex is hard to read. The first part looks for spaces following  end-of-sentence punctuation. The second part matches at the end of the string.</p><p>Regex in Julia uses an r identifier prefix.</p><p><strong>References</strong></p><p>https://www.geeksforgeeks.org/regular-expressions-in-julia/</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Juissie-GW/Juissie.jl/blob/34156a4b45050aa4c03cf687cbb0d750b1bb1789/src/SemanticSearch/TextUtils.jl#L54-L74">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.3.0 on <span class="colophon-date" title="Tuesday 9 April 2024 21:55">Tuesday 9 April 2024</span>. Using Julia version 1.10.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
